<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Print Price Calculator</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-b from-slate-100 to-slate-200 min-h-screen py-8 px-4 md:px-8">
  <div id="root" class="max-w-6xl mx-auto bg-transparent"></div>

  <!-- React, ReactDOM, jsPDF, pdfjsLib, Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;
    const { jsPDF } = window.jspdf;

    // Preset sheet dimensions (inches)
    const PRESET_SHEETS = {
      "8.5x11": [8.5, 11],
      "11x17": [11, 17],
      "12x18": [12, 18],
      custom: null
    };

    const DPI = 300;
    const MARGIN_IN = 0.1;
    const SPACING_IN = 0.05;
    const BLEED_IN = 0.125;

    // Paper types and which sheet sizes they are valid for
    const PAPER_TYPES = [
      { key: '28lb', label: '28 LB Paper' },
      { key: '20lb', label: '20 LB Paper' },
      { key: '80c', label: '80 LB Cardstock Cover' },
      { key: '110c', label: '110 LB Cardstock Cover' },
      { key: '80t', label: '80 LB Text Gloss' },
      { key: '100t', label: '100 LB Text Gloss' },
      { key: '14pt', label: '14PT Gloss' },
      { key: '18pt', label: '18PT Gloss' }
    ];

    // Rules: all paper options are 8.5x11 and 11x17 EXCEPT 14PT/18PT which are only 12x18
    const SHEET_KEYS_FOR_PAPER = {
      '28lb': ['8.5x11', '11x17'],
      '20lb': ['8.5x11', '11x17'],
      '80c': ['8.5x11', '11x17'],
      '110c': ['8.5x11', '11x17'],
      '80t': ['8.5x11', '11x17'],
      '100t': ['8.5x11', '11x17'],
      '14pt': ['12x18'],
      '18pt': ['12x18']
    };

    // Large-format paper types
    const LF_PAPER_TYPES = [
      { key: 'hp-super-heavy-matte', label: 'HP Super Heavyweight Plus Matte Paper' },
      { key: 'hp-universal-gloss-photo', label: 'HP Universal Instant-dry Gloss Photo Paper' },
      { key: 'plain-20lb-bond', label: '20lb Plain Bond Paper' },
      { key: 'lexjet-46-bond', label: 'LexJet #46 Bright White Bond Paper' },
      { key: 'lexjet-thrifty-banner', label: 'LexJet TOUGHcoat ThriftyBanner' },
      { key: 'lexjet-polypro', label: 'LexJet TOUGHcoat Matte Polypropylene v2' },
      { key: 'fredrix-777-matte', label: 'Fredrix 777VWR Vivid Matte Canvas' },
      { key: 'hp-adhesive-matte-polypro', label: 'HP Everyday Adhesive Matte Polypropylene' },
      { key: 'hp-translucent-bond', label: 'HP Translucent Bond Paper' }
    ];

    // Large-format add-ons
    const LF_ADDONS = [
      { key: 'grommets', label: 'Grommets' },
      { key: 'foamcore', label: 'Foam Core Mounting' },
      { key: 'coro', label: 'Coro Sign' }
    ];

    const buildInitialPricing = () => {
      const pricing = {};
      PAPER_TYPES.forEach(pt => {
        pricing[pt.key] = {};
        (SHEET_KEYS_FOR_PAPER[pt.key] || []).forEach(sheetKey => {
          pricing[pt.key][sheetKey] = {
            paperCost: 0,
            colorClickCost: 0,
            bwClickCost: 0,
            priceColor: 0,
            priceBW: 0
          };
        });
      });
      return pricing;
    };

    const buildInitialLfPricing = () => {
      const pricing = {};
      LF_PAPER_TYPES.forEach(pt => {
        pricing[pt.key] = {
          baseCostPerSqFt: 0,
          pricePerSqFt: 0
        };
      });
      return pricing;
    };

    const defaultSheetQtyDiscounts = [
      { minSheets: 100, discountPercent: 5 },
      { minSheets: 250, discountPercent: 10 },
      { minSheets: 500, discountPercent: 15 }
    ];

    const defaultLfQtyDiscounts = [
      { minSqFt: 50, discountPercent: 5 },
      { minSqFt: 150, discountPercent: 10 },
      { minSqFt: 300, discountPercent: 15 }
    ];

    function PriceCalculatorApp() {
      const [viewMode, setViewMode] = useState('tool'); // 'tool' | 'quote'

      // Sheet printing state
      const [sheetKey, setSheetKey] = useState('8.5x11');
      const [customSize, setCustomSize] = useState({ w: 8.5, h: 11 }); // inches
      const [orientation, setOrientation] = useState('portrait');
      const [prints, setPrints] = useState({ width: 5, height: 7, quantity: 2 });

      // Bleed toggle
      const [useBleed, setUseBleed] = useState(false);

      // FRONT/BACK image or PDF-derived image(s)
      const [frontImage, setFrontImage] = useState(null);
      const [backImage, setBackImage] = useState(null);
      const [frontRotation, setFrontRotation] = useState(0);
      const [backRotation, setBackRotation] = useState(0);
      const [frontMode, setFrontMode] = useState('color'); // 'color' | 'bw'
      const [backMode, setBackMode] = useState('color'); // 'color' | 'bw'
      const [showBack, setShowBack] = useState(false);
      const [showGuides, setShowGuides] = useState(true);

      // Multi-page support
      const [frontPages, setFrontPages] = useState([]);
      const [backPages, setBackPages] = useState([]);
      const [multiLayoutMode, setMultiLayoutMode] = useState('1-2'); // '1-2' | '1-1'

      // Multiple front images
      const [extraFrontImages, setExtraFrontImages] = useState([]);

      // Paper type selection
      const [paperKey, setPaperKey] = useState(PAPER_TYPES[0].key);

      // Admin / pricing state
      const [pricing, setPricing] = useState(buildInitialPricing);
      const [lfPricing, setLfPricing] = useState(buildInitialLfPricing);
      const [markupPerPaper, setMarkupPerPaper] = useState(() => {
        const init = {};
        PAPER_TYPES.forEach(pt => { init[pt.key] = 0; });
        return init;
      });
      const [lfMarkupPerPaper, setLfMarkupPerPaper] = useState(() => {
        const init = {};
        LF_PAPER_TYPES.forEach(pt => { init[pt.key] = 0; });
        return init;
      });
      const [isAdmin, setIsAdmin] = useState(false);
      const [showAdmin, setShowAdmin] = useState(false);

      // Sheet quantity discounts
      const [quantityDiscounts, setQuantityDiscounts] =
        useState(defaultSheetQtyDiscounts);

      // Large format quantity discounts
      const [lfQuantityDiscounts, setLfQuantityDiscounts] =
        useState(defaultLfQtyDiscounts);

      // Back-side multiplier (admin configurable)
      const [backSideFactor, setBackSideFactor] = useState(0.5);

      // Large-format job
      const [lfJob, setLfJob] = useState({
        width: 24,
        height: 36,
        quantity: 1
      });
      const [lfImage, setLfImage] = useState(null);
      const [lfRotation, setLfRotation] = useState(0);
      const [lfPaperKey, setLfPaperKey] = useState(LF_PAPER_TYPES[0].key);
      const [lfKeepProportions, setLfKeepProportions] = useState(true);
      const [lfAddonSelections, setLfAddonSelections] = useState({});
      const [lfAddonPricing, setLfAddonPricing] = useState(() => {
        const init = {};
        LF_ADDONS.forEach(a => { init[a.key] = 0; });
        return init;
      });

      // Quick quote state
      const [quoteTarget, setQuoteTarget] = useState({
        width: 5,
        height: 7,
        quantity: 100,
        colorMode: 'color',
        backEnabled: false,
        backColorMode: 'bw'
      });
      const [quoteDocPages, setQuoteDocPages] = useState(1);
      const [quoteDoubleSided, setQuoteDoubleSided] = useState(true);

      // Email/order form modal
      const [showOrderForm, setShowOrderForm] = useState(false);
      const [orderJobType, setOrderJobType] = useState('sheet'); // 'sheet' | 'large'
      const [customerInfo, setCustomerInfo] = useState({
        name: '',
        email: '',
        phone: ''
      });
      const [orderSending, setOrderSending] = useState(false);

      // PDF-specific state
      const [frontPdfData, setFrontPdfData] = useState(null); // Uint8Array
      const [frontPdfPages, setFrontPdfPages] = useState(0);
      const [backPdfData, setBackPdfData] = useState(null); // Uint8Array
      const [backPdfPages, setBackPdfPages] = useState(0);

      const frontRef = useRef();
      const backRef = useRef();
      const lfRef = useRef();

      // Utility: get sheet size in inches [wIn, hIn] for a given key
      const getSheetInchesForKey = (key) => {
        if (key === 'custom') {
          const wRaw = Number(customSize.w) || 0;
          const hRaw = Number(customSize.h) || 0;
          const w = Math.max(0.1, Math.min(36, wRaw));
          const h = Math.max(0.1, hRaw);
          return [w, h];
        }
        return PRESET_SHEETS[key] || [8.5, 11];
      };

      // Utility: get current sheet size in inches [wIn, hIn]
      const getSheetInches = () => getSheetInchesForKey(sheetKey);

      const currentPaper =
        PAPER_TYPES.find(pt => pt.key === paperKey) || PAPER_TYPES[0];

      // Is this sheet/paper combo allowed (for warning only)?
      const comboAllowed = (SHEET_KEYS_FOR_PAPER[paperKey] || []).includes(sheetKey);

      // Normalize pricing entry
      const normalizeEntry = (entry) => {
        return {
          paperCost: Number(entry.paperCost) || 0,
          colorClickCost: Number(entry.colorClickCost) || 0,
          bwClickCost: Number(entry.bwClickCost) || 0,
          priceColor: Number(entry.priceColor) || 0,
          priceBW: Number(entry.priceBW) || 0
        };
      };

      // Capacity helper (how many prints fit on a sheet)
      const computeCapacity = (sheetKeyLocal, orientationLocal, widthIn, heightIn, useBleedLocal) => {
        const [baseWIn, baseHIn] = getSheetInchesForKey(sheetKeyLocal);
        const pageWIn = orientationLocal === 'portrait' ? baseWIn : baseHIn;
        const pageHIn = orientationLocal === 'portrait' ? baseHIn : baseWIn;

        const margin = MARGIN_IN;
        const spacing = SPACING_IN;

        const trimWIn = Math.max(0.01, widthIn);
        const trimHIn = Math.max(0.01, heightIn);

        const perWIn = trimWIn + (useBleedLocal ? 2 * BLEED_IN : 0);
        const perHIn = trimHIn + (useBleedLocal ? 2 * BLEED_IN : 0);

        const usableWIn = pageWIn - 2 * margin;
        const usableHIn = pageHIn - 2 * margin;

        if (usableWIn <= 0 || usableHIn <= 0) return 0;

        const cols = Math.max(
          0,
          Math.floor((usableWIn + spacing) / (perWIn + spacing))
        );
        const rows = Math.max(
          0,
          Math.floor((usableHIn + spacing) / (perHIn + spacing))
        );

        return rows * cols;
      };

      const computePrintsPerSheet = () =>
        computeCapacity(sheetKey, orientation, prints.width, prints.height, useBleed);

      // FRONT/BACK image arrays (single or multi-page)
      const getFrontImages = () => {
        if (frontPages && frontPages.length) return frontPages;
        if (frontImage) return [frontImage];
        if (extraFrontImages && extraFrontImages.length) return extraFrontImages;
        return [];
      };
      const getBackImages = () => {
        if (backPages && backPages.length) return backPages;
        if (backImage) return [backImage];
        return [];
      };

      // LocalStorage keys
      const LS_PRICING_KEY = 'print_tool_pricing_v1';
      const LS_LF_PRICING_KEY = 'print_tool_lf_pricing_v1';
      const LS_QTY_DISCOUNTS_KEY = 'print_tool_qty_discounts_v1';
      const LS_LF_QTY_DISCOUNTS_KEY = 'print_tool_lf_qty_discounts_v1';
      const LS_BACK_FACTOR_KEY = 'print_tool_back_factor_v1';
      const LS_LF_ADDONS_KEY = 'print_tool_lf_addons_v1';

      // Load pricing from localStorage and pricing.json
      useEffect(() => {
        const loadAllPricing = async () => {
          try {
            const savedPricing = window.localStorage.getItem(LS_PRICING_KEY);
            const savedLfPricing = window.localStorage.getItem(LS_LF_PRICING_KEY);
            const savedQty = window.localStorage.getItem(LS_QTY_DISCOUNTS_KEY);
            const savedLfQty = window.localStorage.getItem(LS_LF_QTY_DISCOUNTS_KEY);
            const savedBackFactor = window.localStorage.getItem(LS_BACK_FACTOR_KEY);
            const savedLfAddons = window.localStorage.getItem(LS_LF_ADDONS_KEY);

            if (savedPricing) setPricing(JSON.parse(savedPricing));
            if (savedLfPricing) setLfPricing(JSON.parse(savedLfPricing));
            if (savedQty) setQuantityDiscounts(JSON.parse(savedQty));
            if (savedLfQty) setLfQuantityDiscounts(JSON.parse(savedLfQty));
            if (savedBackFactor) setBackSideFactor(Number(savedBackFactor) || 0.5);
            if (savedLfAddons) setLfAddonPricing(JSON.parse(savedLfAddons));

            const resp = await fetch('pricing.json', { cache: 'no-store' });
            if (resp.ok) {
              const json = await resp.json();
              if (json.sheetPricing) {
                setPricing(json.sheetPricing);
                window.localStorage.setItem(LS_PRICING_KEY, JSON.stringify(json.sheetPricing));
              }
              if (json.lfPricing) {
                setLfPricing(json.lfPricing);
                window.localStorage.setItem(LS_LF_PRICING_KEY, JSON.stringify(json.lfPricing));
              }
              if (json.quantityDiscounts) {
                setQuantityDiscounts(json.quantityDiscounts);
                window.localStorage.setItem(LS_QTY_DISCOUNTS_KEY, JSON.stringify(json.quantityDiscounts));
              }
              if (json.lfQuantityDiscounts) {
                setLfQuantityDiscounts(json.lfQuantityDiscounts);
                window.localStorage.setItem(LS_LF_QTY_DISCOUNTS_KEY, JSON.stringify(json.lfQuantityDiscounts));
              }
              if (typeof json.backSideFactor === 'number') {
                setBackSideFactor(json.backSideFactor);
                window.localStorage.setItem(LS_BACK_FACTOR_KEY, String(json.backSideFactor));
              }
              if (json.lfAddonPricing) {
                setLfAddonPricing(json.lfAddonPricing);
                window.localStorage.setItem(LS_LF_ADDONS_KEY, JSON.stringify(json.lfAddonPricing));
              }
            }
          } catch (err) {
            console.error('Failed to auto-load pricing.json or localStorage', err);
          }
        };
        loadAllPricing();
      }, []);

      // Auto-save to localStorage
      useEffect(() => {
        try {
          window.localStorage.setItem(LS_PRICING_KEY, JSON.stringify(pricing));
        } catch {}
      }, [pricing]);

      useEffect(() => {
        try {
          window.localStorage.setItem(LS_LF_PRICING_KEY, JSON.stringify(lfPricing));
        } catch {}
      }, [lfPricing]);

      useEffect(() => {
        try {
          window.localStorage.setItem(LS_QTY_DISCOUNTS_KEY, JSON.stringify(quantityDiscounts));
        } catch {}
      }, [quantityDiscounts]);

      useEffect(() => {
        try {
          window.localStorage.setItem(LS_LF_QTY_DISCOUNTS_KEY, JSON.stringify(lfQuantityDiscounts));
        } catch {}
      }, [lfQuantityDiscounts]);

      useEffect(() => {
        try {
          window.localStorage.setItem(LS_BACK_FACTOR_KEY, String(backSideFactor));
        } catch {}
      }, [backSideFactor]);

      useEffect(() => {
        try {
          window.localStorage.setItem(LS_LF_ADDONS_KEY, JSON.stringify(lfAddonPricing));
        } catch {}
      }, [lfAddonPricing]);

      // --------- MAIN SHEET PRICING ----------

      const printsPerSheet = computePrintsPerSheet();
      const sheetsNeeded = printsPerSheet > 0
        ? Math.ceil((Math.max(0, prints.quantity) || 0) / printsPerSheet)
        : 0;

      useEffect(() => {
        setPrints(prev => {
          if (!prev) return prev;
          if (prev.quantity < 0) return { ...prev, quantity: 0 };
          return prev;
        });
      }, [sheetsNeeded]);

      const rawSelected = (pricing[paperKey] || {})[sheetKey] || {};
      const selectedPricing = normalizeEntry(rawSelected);

      const baseColorCost = selectedPricing.paperCost + selectedPricing.colorClickCost;
      const baseBWCost = selectedPricing.paperCost + selectedPricing.bwClickCost;

      const priceColor = selectedPricing.priceColor || 0;
      const priceBW = selectedPricing.priceBW || 0;

      const frontUnitPrice = frontMode === 'color' ? priceColor : priceBW;
      const backUnitPrice = backMode === 'color' ? priceColor : priceBW;
      const pricePerSheetBeforeDiscount =
        frontUnitPrice + (showBack ? backSideFactor * backUnitPrice : 0);

      let appliedQtyDiscount = 0;
      if (Array.isArray(quantityDiscounts) && quantityDiscounts.length) {
        quantityDiscounts.forEach((tier) => {
          const min = Number(tier.minSheets) || 0;
          const disc = Number(tier.discountPercent) || 0;
          if (sheetsNeeded >= min && disc > appliedQtyDiscount) {
            appliedQtyDiscount = disc;
          }
        });
      }
      const effectivePricePerSheet =
        pricePerSheetBeforeDiscount * (1 - appliedQtyDiscount / 100);
      const totalCost = (sheetsNeeded * effectivePricePerSheet).toFixed(2);

      // --------- LARGE FORMAT PRICING ----------

      const lfJobWidth = Math.max(0, Number(lfJob.width) || 0);
      const lfJobHeight = Math.max(0, Number(lfJob.height) || 0);
      const lfJobQty = Math.max(0, Number(lfJob.quantity) || 0);
      const lfAreaPerPrintSqFt = (lfJobWidth * lfJobHeight) / 144;
      const lfTotalSqFt = lfAreaPerPrintSqFt * lfJobQty;

      const lfSelectedPricing = lfPricing[lfPaperKey] || { baseCostPerSqFt: 0, pricePerSqFt: 0 };
      const lfBaseCostPerSqFt = lfSelectedPricing.baseCostPerSqFt || 0;
      const lfPricePerSqFtBeforeDiscount = lfSelectedPricing.pricePerSqFt || 0;

      let lfAppliedDiscount = 0;
      if (Array.isArray(lfQuantityDiscounts) && lfQuantityDiscounts.length) {
        lfQuantityDiscounts.forEach(tier => {
          const min = Number(tier.minSqFt) || 0;
          const disc = Number(tier.discountPercent) || 0;
          if (lfTotalSqFt >= min && disc > lfAppliedDiscount) {
            lfAppliedDiscount = disc;
          }
        });
      }
      const lfEffectivePricePerSqFt =
        lfPricePerSqFtBeforeDiscount * (1 - lfAppliedDiscount / 100);
      let lfTotalPrice = lfEffectivePricePerSqFt * lfTotalSqFt;

      let lfAddonTotal = 0;
      LF_ADDONS.forEach(a => {
        const perPrint = Number(lfAddonPricing[a.key]) || 0;
        lfAddonTotal += perPrint * lfJobQty;
      });
      lfTotalPrice += lfAddonTotal;

      // --------- QUICK QUOTE CALCULATIONS (UPDATED) ----------

      const buildAllQuoteOptions = () => {
        const sheetKeysToCheck = ['8.5x11', '11x17', '12x18'];
        const orientations = ['portrait', 'landscape'];
        const results = [];

        sheetKeysToCheck.forEach(sheetKeyCandidate => {
          orientations.forEach(orient => {
            // Quick quote uses TRIM size only (no bleed) for fit
            const capacity = computeCapacity(
              sheetKeyCandidate,
              orient,
              quoteTarget.width,
              quoteTarget.height,
              false // ignore bleed when quoting
            );
            if (capacity <= 0) return;

            PAPER_TYPES.forEach(pt => {
              // Only sheets that this paper type is allowed on
              if (!(SHEET_KEYS_FOR_PAPER[pt.key] || []).includes(sheetKeyCandidate)) return;

              const entryRaw = ((pricing[pt.key] || {})[sheetKeyCandidate]) || {};
              const entry = normalizeEntry(entryRaw);

              // Base costs (paper + clicks)
              const baseColor = entry.paperCost + entry.colorClickCost;
              const baseBW = entry.paperCost + entry.bwClickCost;

              // Use markup price if set; otherwise fall back to base cost
              let frontUnit;
              let backUnit;

              if (quoteTarget.colorMode === 'color') {
                frontUnit = (entry.priceColor || 0) || baseColor;
              } else {
                frontUnit = (entry.priceBW || 0) || baseBW;
              }

              if (quoteTarget.backColorMode === 'color') {
                backUnit = (entry.priceColor || 0) || baseColor;
              } else {
                backUnit = (entry.priceBW || 0) || baseBW;
              }

              // If absolutely no usable price, skip
              if (frontUnit <= 0 && !(quoteTarget.backEnabled && backUnit > 0)) return;

              const perSheetBeforeDisc =
                frontUnit + (quoteTarget.backEnabled ? backSideFactor * backUnit : 0);
              if (perSheetBeforeDisc <= 0) return;

              const sheetsNeededLocal =
                capacity > 0
                  ? Math.ceil((Math.max(0, quoteTarget.quantity) || 0) / capacity)
                  : 0;
              if (sheetsNeededLocal <= 0) return;

              // Apply quantity discount tiers
              let disc = 0;
              if (Array.isArray(quantityDiscounts)) {
                quantityDiscounts.forEach(tier => {
                  const min = Number(tier.minSheets) || 0;
                  const d = Number(tier.discountPercent) || 0;
                  if (sheetsNeededLocal >= min && d > disc) disc = d;
                });
              }

              const perSheetAfterDisc = perSheetBeforeDisc * (1 - disc / 100);
              const total = perSheetAfterDisc * sheetsNeededLocal;

              results.push({
                sheetKey: sheetKeyCandidate,
                orientation: orient,
                paperKey: pt.key,
                paperLabel: pt.label,
                printsPerSheet: capacity,
                sheetsNeeded: sheetsNeededLocal,
                discount: disc,
                pricePerSheet: perSheetAfterDisc,
                totalPrice: total
              });
            });
          });
        });

        return results;
      };

      const allQuoteOptions = buildAllQuoteOptions();
      const sortedQuoteOptions = [...allQuoteOptions].sort((a, b) => {
        const order = ['8.5x11', '11x17', '12x18'];
        if (a.sheetKey !== b.sheetKey) {
          return order.indexOf(a.sheetKey) - order.indexOf(b.sheetKey);
        }
        if (a.paperLabel !== b.paperLabel) {
          return a.paperLabel.localeCompare(b.paperLabel);
        }
        return a.totalPrice - b.totalPrice;
      });

      const recommendedQuote = sortedQuoteOptions.length
        ? sortedQuoteOptions.reduce((best, cur) =>
            !best || cur.totalPrice < best.totalPrice ? cur : best,
            null
          )
        : null;

      const quoteSheetsForDoc = quoteDoubleSided
        ? Math.ceil((Math.max(0, quoteDocPages) || 0) / 2)
        : (Math.max(0, quoteDocPages) || 0);

      // --------- PDF / DRAWING FUNCTIONS ----------

      const buildSheetPdf = async () => {
        const [baseWIn, baseHIn] = getSheetInches();
        let pdfW = baseWIn;
        let pdfH = baseHIn;
        if (orientation === 'landscape') [pdfW, pdfH] = [baseHIn, baseWIn];

        const pdf = new jsPDF({
          orientation,
          unit: 'in',
          format: [pdfW, pdfH]
        });

        const frontImages = getFrontImages();
        const backImages = getBackImages();
        const mainImages = frontImages.length ? frontImages : extraFrontImages;

        if (!mainImages.length) return pdf;

        const renderSheetToCanvas = async (pageIndex, mode, rotation, imagesForSide) => {
          const canvas = document.createElement('canvas');
          await drawLayout(canvas, imagesForSide, rotation, mode, pageIndex);
          return canvas.toDataURL('image/png', 1.0);
        };

        const totalSheets = sheetsNeeded || 1;

        for (let s = 0; s < totalSheets; s++) {
          const frontData = await renderSheetToCanvas(
            s,
            frontMode,
            frontRotation,
            frontImages.length ? frontImages : mainImages
          );
          if (s === 0) {
            pdf.addImage(frontData, 'PNG', 0, 0, pdfW, pdfH);
          } else {
            pdf.addPage([pdfW, pdfH], orientation);
            pdf.addImage(frontData, 'PNG', 0, 0, pdfW, pdfH);
          }

          if (showBack && backImages.length) {
            const backData = await renderSheetToCanvas(
              s,
              backMode,
              backRotation,
              backImages
            );
            pdf.addPage([pdfW, pdfH], orientation);
            pdf.addImage(backData, 'PNG', 0, 0, pdfW, pdfH);
          }
        }

        return pdf;
      };

      const downloadPDF = async () => {
        const pdf = await buildSheetPdf();
        pdf.save('print_preview.pdf');
      };

      const buildLargeFormatPdf = async () => {
        const pdfW = lfJobWidth || 1;
        const pdfH = lfJobHeight || 1;

        const pdf = new jsPDF({
          orientation: pdfW >= pdfH ? 'landscape' : 'portrait',
          unit: 'in',
          format: [pdfW, pdfH]
        });

        if (!lfImage) return pdf;

        const canvas = document.createElement('canvas');
        await drawLargeFormatLayout(canvas);
        const dataUrl = canvas.toDataURL('image/png', 1.0);

        pdf.addImage(dataUrl, 'PNG', 0, 0, pdfW, pdfH);
        return pdf;
      };

      const downloadLargeFormatPDF = async () => {
        const pdf = await buildLargeFormatPdf();
        pdf.save('large_format_preview.pdf');
      };

      // ----- ORDER EMAIL -----
      const sendOrderEmail = async (jobType, pdfBuilder) => {
        try {
          setOrderSending(true);
          const pdf = await pdfBuilder();
          const pdfBase64 = pdf.output('datauristring').split(',')[1] || '';

          console.log('pdfBase64 length (client):', pdfBase64.length);

          if (pdfBase64.length > 8000000) {
            alert(
              'This file is very large. Please download the PDF instead and email it manually to store4979@theupsstore.com.'
            );
            setOrderSending(false);
            return;
          }

          const detailsLines = [];

          if (jobType === 'sheet') {
            const [baseWIn, baseHIn] = getSheetInches();
            detailsLines.push(`Base sheet: ${sheetKey} (${baseWIn} x ${baseHIn} in, ${orientation})`);
            detailsLines.push(`Target size: ${prints.width} x ${prints.height} in`);
            detailsLines.push(`Quantity: ${prints.quantity}`);
            detailsLines.push(`Sheets needed: ${sheetsNeeded}`);
            detailsLines.push(`Paper type: ${
              (PAPER_TYPES.find(p => p.key === paperKey) || {}).label || paperKey
            }`);
            detailsLines.push(`Front mode: ${frontMode === 'color' ? 'Color' : 'B/W'}`);
            if (showBack) {
              detailsLines.push(`Back enabled: Yes (${backMode === 'color' ? 'Color' : 'B/W'})`);
              detailsLines.push(`Back side factor: ${backSideFactor}`);
            } else {
              detailsLines.push('Back enabled: No');
            }
            detailsLines.push(`Use bleed: ${useBleed ? 'Yes' : 'No'}`);
            detailsLines.push(`Total price: $${totalCost}`);
          } else if (jobType === 'large') {
            detailsLines.push(`Large format size: ${lfJobWidth} x ${lfJobHeight} in`);
            detailsLines.push(`Quantity: ${lfJobQty}`);
            detailsLines.push(
              `Paper: ${
                (LF_PAPER_TYPES.find(p => p.key === lfPaperKey) || {}).label || lfPaperKey
              }`
            );
            detailsLines.push(`Keep proportions: ${lfKeepProportions ? 'Yes' : 'No'}`);
            const selectedAddons = LF_ADDONS.filter(a => lfAddonSelections[a.key]);
            if (selectedAddons.length) {
              detailsLines.push(
                `Add-ons: ${selectedAddons.map(a => a.label).join(', ')}`
              );
            } else {
              detailsLines.push('Add-ons: None');
            }
            detailsLines.push(`Total large format price: $${lfTotalPrice.toFixed(2)}`);
          }

          detailsLines.push('');
          detailsLines.push('Customer Info:');
          detailsLines.push(`Name: ${customerInfo.name || '(not provided)'}`);
          detailsLines.push(`Email: ${customerInfo.email || '(not provided)'}`);
          detailsLines.push(`Phone: ${customerInfo.phone || '(not provided)'}`);

          const body = {
            subject: 'PRINT JOB',
            to: 'store4979@theupsstore.com',
            jobType,
            details: detailsLines.join('\n'),
            pdfBase64
          };

          const resp = await fetch('/.netlify/functions/send-print-job', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          if (!resp.ok) {
            console.error('Server error:', resp.status, await resp.text());
            alert(
              'Could not send order automatically. Please download the PDF and email it to store4979@theupsstore.com.'
            );
          } else {
            alert('Order sent successfully! We will contact you to confirm your job.');
          }
        } catch (err) {
          console.error('sendOrderEmail error:', err);
          alert(
            'Could not send order automatically. Please download the PDF and email it to store4979@theupsstore.com.'
          );
        } finally {
          setOrderSending(false);
          setShowOrderForm(false);
        }
      };

      const orderSheetJob = () => {
        setOrderJobType('sheet');
        setShowOrderForm(true);
      };

      const orderLargeJob = () => {
        setOrderJobType('large');
        setShowOrderForm(true);
      };

      const handleStartOrder = (jobType) => {
        if (jobType === 'sheet') orderSheetJob();
        else orderLargeJob();
      };

      // ---- PDF upload -> rasterize selected page(s) to image(s) ----
      async function loadPdfToState(file, side) {
        const data = new Uint8Array(await file.arrayBuffer());
        const pdf = await pdfjsLib.getDocument({ data }).promise;
        const pages = pdf.numPages;

        const images = [];
        for (let i = 1; i <= pages; i++) {
          const imgFile = await rasterizePdfPageToFile(data, i);
          images.push(imgFile);
        }

        if (side === 'front') {
          setFrontPdfData(data);
          setFrontPdfPages(pages);
          setFrontPages(images);
          setFrontImage(images[0] || null);
        } else {
          setBackPdfData(data);
          setBackPdfPages(pages);
          setBackPages(images);
          setBackImage(images[0] || null);
        }
      }

      async function rasterizePdfPageToFile(pdfData, pageNum) {
        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 3 });
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        c.width = viewport.width;
        c.height = viewport.height;
        await page.render({ canvasContext: ctx, viewport }).promise;
        return new Promise((resolve) => {
          c.toBlob(
            (blob) =>
              resolve(new File([blob], `page-${pageNum}.png`, { type: 'image/png' })),
            'image/png',
            1.0
          );
        });
      }

      const drawLayout = (canvas, images, rotationDeg, colorMode, sheetIndex) => {
        if (!canvas) return Promise.resolve();
        const ctx = canvas.getContext('2d');
        const [baseWIn, baseHIn] = getSheetInches();
        const pageWIn = orientation === 'portrait' ? baseWIn : baseHIn;
        const pageHIn = orientation === 'portrait' ? baseHIn : baseWIn;

        const pageWPx = Math.round(pageWIn * DPI);
        const pageHPx = Math.round(pageHIn * DPI);
        const marginPx = MARGIN_IN * DPI;
        const spacingPx = SPACING_IN * DPI;

        canvas.width = pageWPx;
        canvas.height = pageHPx;

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, pageWPx, pageHPx);

        if (!images || !images.length) return Promise.resolve();

        const trimWIn = Math.max(0.01, prints.width);
        const trimHIn = Math.max(0.01, prints.height);
        const fullWIn = trimWIn + (useBleed ? 2 * BLEED_IN : 0);
        const fullHIn = trimHIn + (useBleed ? 2 * BLEED_IN : 0);

        const tileWPx = fullWIn * DPI;
        const tileHPx = fullHIn * DPI;

        const cols = Math.max(
          0,
          Math.floor((pageWPx - 2 * marginPx + spacingPx) / (tileWPx + spacingPx))
        );
        const rows = Math.max(
          0,
          Math.floor((pageHPx - 2 * marginPx + spacingPx) / (tileHPx + spacingPx))
        );

        if (cols <= 0 || rows <= 0) return Promise.resolve();

        const totalTiles = rows * cols;
        const globalStartIndex = sheetIndex * totalTiles;

        let tilesToDraw = Math.min(
          totalTiles,
          Math.max(0, prints.quantity - globalStartIndex)
        );
        if (tilesToDraw <= 0) tilesToDraw = totalTiles; // for preview

        const totalWidthPx = cols * tileWPx + (cols - 1) * spacingPx;
        const totalHeightPx = rows * tileHPx + (rows - 1) * spacingPx;

        const startX =
          marginPx + (pageWPx - 2 * marginPx - totalWidthPx) / 2;
        const startY =
          marginPx + (pageHPx - 2 * marginPx - totalHeightPx) / 2;

        const loadImage = (file) =>
          new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => resolve(null);
            img.src = URL.createObjectURL(file);
          });

        let firstTrimX = null;
        let firstTrimY = null;

        const drawOneCell = async (imgFile, x, y) => {
          const img = await loadImage(imgFile);
          if (!img) return;

          const rad = (rotationDeg * Math.PI) / 180;

          const drawWidthPx = trimWIn * DPI;
          const drawHeightPx = trimHIn * DPI;

          const bleedPx = useBleed ? BLEED_IN * DPI : 0;

          const centerX = x + tileWPx / 2;
          const centerY = y + tileHPx / 2;

          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(rad);

          const sx = -drawWidthPx / 2 - bleedPx;
          const sy = -drawHeightPx / 2 - bleedPx;
          const sw = drawWidthPx + 2 * bleedPx;
          const sh = drawHeightPx + 2 * bleedPx;

          ctx.drawImage(img, sx, sy, sw, sh);

          if (colorMode === 'bw') {
            const imageData = ctx.getImageData(-pageWPx * 2, -pageHPx * 2, pageWPx * 4, pageHPx * 4);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const avg = 0.299 * r + 0.587 * g + 0.114 * b;
              data[i] = data[i + 1] = data[i + 2] = avg;
            }
            ctx.putImageData(imageData, -pageWPx * 2, -pageHPx * 2);
          }

          ctx.restore();

          const trimLeftX = centerX - drawWidthPx / 2;
          const trimTopY = centerY - drawHeightPx / 2;

          ctx.save();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 0.75;
          ctx.setLineDash([6, 4]);
          ctx.strokeRect(
            centerX - drawWidthPx / 2,
            centerY - drawHeightPx / 2,
            drawWidthPx,
            drawHeightPx
          );
          ctx.restore();

          if (firstTrimX === null) {
            firstTrimX = trimLeftX;
            firstTrimY = trimTopY;
          }
        };

        const loadPromises = [];
        let drawn = 0;
        for (let r = 0; r < rows && drawn < tilesToDraw; r++) {
          for (let c = 0; c < cols && drawn < tilesToDraw; c++) {
            const idx = (globalStartIndex + drawn) % images.length;
            const file = images[idx];
            const tileX = startX + c * (tileWPx + spacingPx);
            const tileY = startY + r * (tileHPx + spacingPx);

            loadPromises.push(drawOneCell(file, tileX, tileY));
            drawn++;
          }
        }

        return Promise.all(loadPromises).then(() => {
          if (showGuides && firstTrimX !== null) {
            const gap = 20;
            const ctx2 = ctx;
            ctx2.strokeStyle = 'red';
            ctx2.fillStyle = 'red';
            ctx2.lineWidth = 1;

            const leftDistIn = firstTrimX / DPI;
            const topDistIn = firstTrimY / DPI;
            const leftLabel = leftDistIn.toFixed(2) + ' in';
            const topLabel = topDistIn.toFixed(2) + ' in';

            ctx2.beginPath();
            ctx2.moveTo(0, firstTrimY + gap);
            ctx2.lineTo(firstTrimX, firstTrimY + gap);
            ctx2.stroke();
            const leftTextWidth = ctx2.measureText(leftLabel).width;
            ctx2.fillText(
              leftLabel,
              (firstTrimX - leftTextWidth) / 2,
              firstTrimY + gap - 4
            );

            ctx2.beginPath();
            ctx2.moveTo(firstTrimX + gap, 0);
            ctx2.lineTo(firstTrimX + gap, firstTrimY);
            ctx2.stroke();
            ctx2.fillText(
              topLabel,
              firstTrimX + gap + 4,
              firstTrimY / 2 + 4
            );
          }
        });
      };

      const drawLargeFormatLayout = async (canvas) => {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const widthPx = Math.max(100, Math.round(lfJobWidth * DPI));
        const heightPx = Math.max(100, Math.round(lfJobHeight * DPI));
        canvas.width = widthPx;
        canvas.height = heightPx;

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, widthPx, heightPx);

        if (!lfImage) return;

        const img = await new Promise((resolve) => {
          const i = new Image();
          i.onload = () => resolve(i);
          i.onerror = () => resolve(null);
          i.src = URL.createObjectURL(lfImage);
        });
        if (!img) return;

        let drawW = widthPx;
        let drawH = heightPx;

        const rad = (lfRotation * Math.PI) / 180;
        const centerX = widthPx / 2;
        const centerY = heightPx / 2;

        if (lfKeepProportions) {
          const w0 = img.width;
          const h0 = img.height;
          const origAspect = w0 / h0;
          const targetAspect = widthPx / heightPx;

          if (origAspect > targetAspect) {
            drawW = widthPx;
            drawH = widthPx / origAspect;
          } else {
            drawH = heightPx;
            drawW = heightPx * origAspect;
          }
        }

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rad);
        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, widthPx, heightPx);
        ctx.restore();
      };

      useEffect(() => {
        const images = getFrontImages();
        if (frontRef.current) {
          drawLayout(frontRef.current, images, frontRotation, frontMode, 0);
        }
      }, [sheetKey, customSize, orientation, prints, frontImage, frontPages, extraFrontImages, frontRotation, frontMode, useBleed, showGuides, paperKey]);

      useEffect(() => {
        if (showBack) {
          const images = getBackImages();
          if (backRef.current) {
            drawLayout(backRef.current, images, backRotation, backMode, 0);
          }
        }
      }, [sheetKey, customSize, orientation, prints, backImage, backPages, backRotation, backMode, showBack, useBleed, showGuides]);

      useEffect(() => {
        if (lfRef.current) {
          drawLargeFormatLayout(lfRef.current);
        }
      }, [lfJob, lfImage, lfRotation, lfKeepProportions]);

      const handleAdminClick = () => {
        if (!isAdmin) {
          const pwd = window.prompt('Enter admin password');
          if (pwd === 'store4979') {
            setIsAdmin(true);
            setShowAdmin(true);
          } else {
            window.alert('Incorrect password');
          }
        } else {
          setShowAdmin(v => !v);
        }
      };

      const applyMarkupForPaper = (pk) => {
        const m = parseFloat(markupPerPaper[pk]) || 0;
        const factor = 1 + m / 100;
        setPricing(prev => {
          const next = { ...prev };
          const group = prev[pk] || {};
          next[pk] = {};
          for (const sk in group) {
            const entry = group[sk];
            const normalized = normalizeEntry(entry);
            const baseColor = normalized.paperCost + normalized.colorClickCost;
            const baseBW = normalized.paperCost + normalized.bwClickCost;
            next[pk][sk] = {
              ...normalized,
              priceColor: parseFloat((baseColor * factor).toFixed(4)),
              priceBW: parseFloat((baseBW * factor).toFixed(4))
            };
          }
          return next;
        });
      };

      const applyMarkupForAllPapers = () => {
        setPricing(prev => {
          const next = {};
          for (const pk in prev) {
            const m = parseFloat(markupPerPaper[pk]) || 0;
            const factor = 1 + m / 100;
            const group = prev[pk] || {};
            next[pk] = {};
            for (const sk in group) {
              const entry = group[sk];
              const normalized = normalizeEntry(entry);
              const baseColor = normalized.paperCost + normalized.colorClickCost;
              const baseBW = normalized.paperCost + normalized.bwClickCost;
              next[pk][sk] = {
                ...normalized,
                priceColor: parseFloat((baseColor * factor).toFixed(4)),
                priceBW: parseFloat((baseBW * factor).toFixed(4))
              };
            }
          }
          return next;
        });
      };

      const applyLfMarkupForPaper = (pk) => {
        const m = parseFloat(lfMarkupPerPaper[pk]) || 0;
        const factor = 1 + m / 100;
        setLfPricing(prev => {
          const next = { ...prev };
          const group = prev[pk] || {};
          next[pk] = {
            ...group,
            pricePerSqFt: parseFloat((group.baseCostPerSqFt * factor || 0).toFixed(4))
          };
          return next;
        });
      };

      const applyLfMarkupForAll = () => {
        setLfPricing(prev => {
          const next = {};
          for (const pk in prev) {
            const m = parseFloat(lfMarkupPerPaper[pk]) || 0;
            const factor = 1 + m / 100;
            const entry = prev[pk] || {};
            next[pk] = {
              ...entry,
              pricePerSqFt: parseFloat((entry.baseCostPerSqFt * factor || 0).toFixed(4))
            };
          }
          return next;
        });
      };

      // Pricing import/export
      const exportPricingJson = () => {
        const payload = {
          sheetPricing: pricing,
          lfPricing,
          quantityDiscounts,
          lfQuantityDiscounts,
          backSideFactor,
          lfAddonPricing
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], {
          type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pricing-export.json';
        a.click();
        URL.revokeObjectURL(url);
      };

      const importPricingJson = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const json = JSON.parse(e.target.result);
            if (json.sheetPricing) setPricing(json.sheetPricing);
            if (json.lfPricing) setLfPricing(json.lfPricing);
            if (json.quantityDiscounts) setQuantityDiscounts(json.quantityDiscounts);
            if (json.lfQuantityDiscounts) setLfQuantityDiscounts(json.lfQuantityDiscounts);
            if (typeof json.backSideFactor === 'number') setBackSideFactor(json.backSideFactor);
            if (json.lfAddonPricing) setLfAddonPricing(json.lfAddonPricing);
          } catch {
            alert('Invalid pricing JSON file.');
          }
        };
        reader.readAsText(file);
      };

      // ---- UI ----
      return (
        <div className="bg-white/90 backdrop-blur-lg rounded-3xl shadow-xl border border-slate-200 p-5 md:p-7 space-y-8">
          {/* Top header card */}
          <div className="bg-white/90 backdrop-blur border border-slate-200 rounded-2xl shadow-md px-5 py-5 space-y-4">
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div>
                <h1 className="text-3xl font-bold text-slate-900 tracking-tight">
                  Print &amp; Quote Center
                </h1>
                <p className="text-sm text-slate-500 mt-1 max-w-xl">
                  Easily preview your prints, see live pricing, and send your job directly to our store.
                  No guesswork, no surprises.
                </p>
              </div>
              <div className="flex items-center gap-3">
                <div className="bg-slate-100 rounded-full p-1 inline-flex">
                  <button
                    type="button"
                    onClick={() => setViewMode('tool')}
                    className={
                      'px-4 py-1.5 text-xs font-medium rounded-full transition ' +
                      (viewMode === 'tool'
                        ? 'bg-slate-900 text-white shadow-sm'
                        : 'text-slate-600 hover:bg-slate-200')
                    }
                  >
                    Layout &amp; Orders
                  </button>
                  <button
                    type="button"
                    onClick={() => setViewMode('quote')}
                    className={
                      'px-4 py-1.5 text-xs font-medium rounded-full transition ' +
                      (viewMode === 'quote'
                        ? 'bg-slate-900 text-white shadow-sm'
                        : 'text-slate-600 hover:bg-slate-200')
                    }
                  >
                    Quick Quote
                  </button>
                </div>
                <button
                  type="button"
                  onClick={handleAdminClick}
                  className="px-3 py-1.5 border border-slate-300 rounded-full text-xs bg-white hover:bg-slate-50 transition"
                >
                  {isAdmin ? (showAdmin ? 'Hide Admin' : 'Show Admin') : 'Admin / Pricing'}
                </button>
              </div>
            </div>

            <div className="grid md:grid-cols-3 gap-3 text-xs text-slate-600">
              <div className="flex items-start gap-2">
                <div className="h-6 w-6 rounded-full bg-slate-900 text-white flex items-center justify-center text-[11px] font-semibold">
                  1
                </div>
                <div>
                  <div className="font-semibold text-slate-800">Choose size &amp; paper</div>
                  <div>Pick your base sheet or large format size, paper type, and quantity.</div>
                </div>
              </div>
              <div className="flex items-start gap-2">
                <div className="h-6 w-6 rounded-full bg-slate-900 text-white flex items-center justify-center text-[11px] font-semibold">
                  2
                </div>
                <div>
                  <div className="font-semibold text-slate-800">Upload &amp; preview</div>
                  <div>Drop in your file, adjust orientation/bleed, and check the layout.</div>
                </div>
              </div>
              <div className="flex items-start gap-2">
                <div className="h-6 w-6 rounded-full bg-slate-900 text-white flex items-center justify-center text-[11px] font-semibold">
                  3
                </div>
                <div>
                  <div className="font-semibold text-slate-800">Download or order</div>
                  <div>Download a print-ready PDF or click <span className="font-medium">Order Prints</span> to send it to us.</div>
                </div>
              </div>
            </div>
          </div>

          {/* MAIN TOOL VIEW */}
          {viewMode === 'tool' && (
            <>
              {/* SHEET PRINTING CONTROLS */}
              <div className="flex flex-wrap gap-4 items-end">
                <div>
                  <label className="block text-sm font-medium">Base Sheet</label>
                  <select
                    value={sheetKey}
                    onChange={(e) => setSheetKey(e.target.value)}
                    className="border p-1 rounded"
                  >
                    <option value="8.5x11">8.5 × 11 in</option>
                    <option value="11x17">11 × 17 in</option>
                    <option value="12x18">12 × 18 in</option>
                    <option value="custom">Custom…</option>
                  </select>
                  {!comboAllowed && (
                    <p className="text-xs text-red-600 mt-1">
                      Note: {(currentPaper || {}).label} is not normally used with {sheetKey}.
                    </p>
                  )}
                </div>
                {sheetKey === 'custom' && (
                  <div className="flex items-end gap-3">
                    <div>
                      <label className="block text-sm font-medium">Custom Width (in)</label>
                      <input
                        type="number"
                        min="0.1"
                        step="0.01"
                        value={customSize.w}
                        onChange={(e) =>
                          setCustomSize((s) => ({ ...s, w: +e.target.value || 0 }))
                        }
                        className="border p-1 w-28 rounded"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium">Custom Height (in)</label>
                      <input
                        type="number"
                        min="0.1"
                        step="0.01"
                        value={customSize.h}
                        onChange={(e) =>
                          setCustomSize((s) => ({ ...s, h: +e.target.value || 0 }))
                        }
                        className="border p-1 w-28 rounded"
                      />
                    </div>
                  </div>
                )}

                <div className="space-x-2">
                  <label className="text-sm font-medium mr-2">Orientation</label>
                  <button
                    onClick={() => setOrientation('portrait')}
                    className={`border p-1 rounded text-sm ${
                      orientation === 'portrait' ? 'bg-white shadow-sm' : 'bg-gray-100'
                    }`}
                  >
                    Portrait
                  </button>
                  <button
                    onClick={() => setOrientation('landscape')}
                    className={`border p-1 rounded text-sm ${
                      orientation === 'landscape' ? 'bg-white shadow-sm' : 'bg-gray-100'
                    }`}
                  >
                    Landscape
                  </button>
                </div>
                <div className="flex space-x-2 items-end">
                  <div>
                    <label className="block text-sm font-medium">Print W (in)</label>
                    <input
                      type="number"
                      value={prints.width}
                      onChange={(e) =>
                        setPrints((p) => ({ ...p, width: +e.target.value || 0 }))
                      }
                      className="border p-1 w-24 rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Print H (in)</label>
                    <input
                      type="number"
                      value={prints.height}
                      onChange={(e) =>
                        setPrints((p) => ({ ...p, height: +e.target.value || 0 }))
                      }
                      className="border p-1 w-24 rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Qty</label>
                    <input
                      type="number"
                      value={prints.quantity}
                      onChange={(e) =>
                        setPrints((p) => ({ ...p, quantity: +e.target.value || 0 }))
                      }
                      className="border p-1 w-20 rounded"
                    />
                  </div>
                </div>
                <div className="flex items-center gap-2 ml-auto">
                  <label className="flex items-center text-xs text-slate-600">
                    <input
                      type="checkbox"
                      className="mr-1"
                      checked={useBleed}
                      onChange={(e) => setUseBleed(e.target.checked)}
                    />
                    Add 0.125&quot; bleed
                  </label>
                  <label className="flex items-center text-xs text-slate-600">
                    <input
                      type="checkbox"
                      className="mr-1"
                      checked={showGuides}
                      onChange={(e) => setShowGuides(e.target.checked)}
                    />
                    Show margin distances
                  </label>
                </div>
              </div>

              {/* Paper type buttons */}
              <div className="space-y-2">
                <span className="block text-sm font-medium">Paper Type</span>
                <div className="flex flex-wrap gap-2">
                  {PAPER_TYPES.map((opt) => (
                    <button
                      key={opt.key}
                      type="button"
                      onClick={() => setPaperKey(opt.key)}
                      className={`px-3 py-1 border rounded-full text-xs ${
                        paperKey === opt.key
                          ? 'bg-blue-600 text-white shadow-sm'
                          : 'bg-white hover:bg-slate-50'
                      }`}
                    >
                      {opt.label}
                    </button>
                  ))}
                </div>
                {!comboAllowed && (
                  <p className="text-xs text-red-600">
                    Note: {currentPaper.label} is usually paired with{' '}
                    {SHEET_KEYS_FOR_PAPER[paperKey].join(' or ')}.
                  </p>
                )}
              </div>

              <div className="grid md:grid-cols-2 gap-6">
                {/* FRONT controls */}
                <div className="space-y-3">
                  <h2 className="font-semibold text-sm">Front</h2>
                  <div className="flex flex-wrap items-center gap-3 text-xs">
                    <input
                      type="file"
                      accept="image/*,application/pdf"
                      multiple
                      onChange={async (e) => {
                        const files = Array.from(e.target.files || []);
                        if (!files.length) return;

                        const pdfs = files.filter(f => f.type === 'application/pdf');
                        const imgs = files.filter(f => f.type !== 'application/pdf');

                        if (pdfs.length) {
                          await loadPdfToState(pdfs[0], 'front');
                        } else if (imgs.length === 1) {
                          setFrontPdfData(null);
                          setFrontPdfPages(0);
                          setFrontPages([]);
                          setFrontImage(imgs[0]);
                          setExtraFrontImages([]);
                        } else if (imgs.length > 1) {
                          setFrontPdfData(null);
                          setFrontPdfPages(0);
                          setFrontPages([]);
                          setFrontImage(imgs[0]);
                          setExtraFrontImages(imgs);
                        }
                      }}
                      className="border p-1 rounded bg-white"
                    />
                    <button
                      onClick={() => setFrontRotation((r) => r + 90)}
                      className="border p-1 rounded text-xs bg-white"
                    >
                      Rotate 90°
                    </button>
                    <div className="flex items-center gap-1">
                      <span className="text-xs">Mode:</span>
                      <button
                        type="button"
                        onClick={() => setFrontMode('color')}
                        className={`px-2 py-1 border rounded text-xs ${
                          frontMode === 'color' ? 'bg-emerald-500 text-white' : 'bg-white'
                        }`}
                      >
                        Color
                      </button>
                      <button
                        type="button"
                        onClick={() => setFrontMode('bw')}
                        className={`px-2 py-1 border rounded text-xs ${
                          frontMode === 'bw' ? 'bg-slate-700 text-white' : 'bg-white'
                        }`}
                      >
                        B/W
                      </button>
                    </div>
                    {frontPdfPages > 1 && (
                      <div className="mt-2 text-xs flex flex-wrap items-center gap-2">
                        <span>Multi-page layout:</span>
                        <button
                          type="button"
                          onClick={() => setMultiLayoutMode('1-2')}
                          className={`px-2 py-1 border rounded ${
                            multiLayoutMode === '1-2' ? 'bg-blue-500 text-white' : 'bg-white'
                          }`}
                        >
                          1–2 (sequential pages per sheet)
                        </button>
                        <button
                          type="button"
                          onClick={() => setMultiLayoutMode('1-1')}
                          className={`px-2 py-1 border rounded ${
                            multiLayoutMode === '1-1' ? 'bg-blue-500 text-white' : 'bg-white'
                          }`}
                        >
                          1–1 (same page per side)
                        </button>
                      </div>
                    )}
                  </div>
                  <canvas ref={frontRef} className="w-full h-auto border rounded bg-white" />
                </div>

                {/* BACK controls */}
                <div className="space-y-3">
                  <div className="flex items-center justify-between">
                    <h2 className="font-semibold text-sm">Back</h2>
                    <label className="text-xs flex items-center">
                      <input
                        type="checkbox"
                        checked={showBack}
                        onChange={(e) => setShowBack(e.target.checked)}
                        className="mr-1"
                      />
                      Enable back printing
                    </label>
                  </div>
                  {showBack && (
                    <>
                      <div className="flex flex-wrap items-center gap-3 text-xs">
                        <input
                          type="file"
                          accept="image/*,application/pdf"
                          onChange={async (e) => {
                            const f = e.target.files[0];
                            if (!f) return;
                            if (f.type === 'application/pdf') {
                              await loadPdfToState(f, 'back');
                            } else {
                              setBackPdfData(null);
                              setBackPdfPages(0);
                              setBackPages([]);
                              setBackImage(f);
                            }
                          }}
                          className="border p-1 rounded bg-white"
                        />
                        <button
                          onClick={() => setBackRotation((r) => r + 90)}
                          className="border p-1 rounded text-xs bg-white"
                        >
                          Rotate 90°
                        </button>
                        <div className="flex items-center gap-1">
                          <span className="text-xs">Mode:</span>
                          <button
                            type="button"
                            onClick={() => setBackMode('color')}
                            className={`px-2 py-1 border rounded text-xs ${
                              backMode === 'color' ? 'bg-emerald-500 text-white' : 'bg-white'
                            }`}
                          >
                            Color
                          </button>
                          <button
                            type="button"
                            onClick={() => setBackMode('bw')}
                            className={`px-2 py-1 border rounded text-xs ${
                              backMode === 'bw' ? 'bg-slate-700 text-white' : 'bg-white'
                            }`}
                          >
                            B/W
                          </button>
                        </div>
                        {backPdfPages > 1 && (
                          <div className="flex items-center gap-2 text-xs">
                            <label>Pages</label>
                            <span>({backPdfPages} pages loaded)</span>
                          </div>
                        )}
                      </div>
                      <canvas ref={backRef} className="w-full h-auto border rounded bg-white" />
                    </>
                  )}
                </div>
              </div>

              <div className="mt-4 flex items-center gap-6 flex-wrap">
                <div className="text-sm text-slate-700 space-y-1">
                  <p>Sheets needed: <span className="font-semibold">{sheetsNeeded}</span></p>
                  <p>Selected paper: <span className="font-semibold">{currentPaper.label}</span></p>
                  <p className="text-xs text-slate-500">
                    Price per sheet (with markup, before qty discount): $
                    {pricePerSheetBeforeDiscount.toFixed(4)}
                  </p>
                  <p className="text-xs text-slate-500">
                    Quantity discount applied: {appliedQtyDiscount}%
                  </p>
                  <p className="text-[11px] text-slate-500 mt-1">
                    Estimated total (before tax)
                  </p>
                  <p className="text-2xl font-extrabold text-blue-700">
                    ${totalCost}
                  </p>
                  <p className="text-[11px] text-slate-500">
                    ≈ ${effectivePricePerSheet.toFixed(2)} per sheet
                  </p>
                </div>

                <div className="flex gap-3">
                  <button
                    onClick={downloadPDF}
                    className="bg-blue-500 text-white px-4 py-2 rounded-full text-xs shadow-sm hover:bg-blue-600 transition"
                  >
                    Download Preview (PDF)
                  </button>
                  <button
                    onClick={() => handleStartOrder('sheet')}
                    className="bg-emerald-600 text-white px-4 py-2 rounded-full text-xs shadow-sm hover:bg-emerald-500 transition"
                  >
                    Order Prints – Send to Store
                  </button>
                </div>
              </div>

              {/* LARGE FORMAT SECTION */}
              <div className="mt-8 border-t pt-4">
                <h2 className="text-lg font-semibold mb-2">Large Format Printing</h2>
                <p className="text-xs text-gray-600 mb-3">
                  For roll-based wide prints. Width is limited to 36&quot; maximum.
                </p>

                <div className="flex flex-wrap gap-4 items-end mb-4">
                  <div>
                    <label className="block text-sm font-medium">Width (in)</label>
                    <input
                      type="number"
                      min="0.1"
                      max="36"
                      step="0.01"
                      value={lfJob.width}
                      onChange={e =>
                        setLfJob(job => ({
                          ...job,
                          width: Math.min(36, +e.target.value || 0)
                        }))
                      }
                      className="border p-1 w-24 rounded"
                    />
                    <p className="text-xs text-gray-500 mt-1">Max 36&quot; wide</p>
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Height / Length (in)</label>
                    <input
                      type="number"
                      min="0.1"
                      step="0.01"
                      value={lfJob.height}
                      onChange={e =>
                        setLfJob(job => ({ ...job, height: +e.target.value || 0 }))
                      }
                      className="border p-1 w-24 rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Quantity</label>
                    <input
                      type="number"
                      min="1"
                      step="1"
                      value={lfJob.quantity}
                      onChange={e =>
                        setLfJob(job => ({ ...job, quantity: +e.target.value || 0 }))
                      }
                      className="border p-1 w-24 rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Paper</label>
                    <select
                      value={lfPaperKey}
                      onChange={e => setLfPaperKey(e.target.value)}
                      className="border p-1 rounded"
                    >
                      {LF_PAPER_TYPES.map(pt => (
                        <option key={pt.key} value={pt.key}>
                          {pt.label}
                        </option>
                      ))}
                    </select>
                  </div>
                  <div className="flex flex-col text-xs text-slate-700">
                    <label className="flex items-center">
                      <input
                        type="checkbox"
                        className="mr-1"
                        checked={lfKeepProportions}
                        onChange={e => setLfKeepProportions(e.target.checked)}
                      />
                      Keep proportions of uploaded image
                    </label>
                    {!lfKeepProportions && (
                      <span className="text-[11px] text-amber-700 mt-1">
                        Image may be stretched to fit target size.
                      </span>
                    )}
                  </div>
                </div>

                <div className="grid md:grid-cols-2 gap-6 items-start mb-4">
                  <div className="space-y-2">
                    <h3 className="font-semibold text-sm">Large Format Preview</h3>
                    <div className="flex flex-wrap items-center gap-3 text-xs">
                      <input
                        type="file"
                        accept="image/*"
                        onChange={(e) => {
                          const f = e.target.files[0];
                          if (!f) return;
                          setLfImage(f);
                        }}
                        className="border p-1 rounded bg-white"
                      />
                      <button
                        type="button"
                        onClick={() => setLfRotation(r => r + 90)}
                        className="border p-1 text-sm bg-white rounded"
                      >
                        Rotate 90°
                      </button>
                    </div>
                    <canvas ref={lfRef} className="w-full h-auto border rounded bg-white" />
                  </div>

                  <div className="space-y-2 text-sm text-slate-700">
                    <h3 className="font-semibold text-sm">Large Format Summary</h3>
                    <p>Approx. area per print: {lfAreaPerPrintSqFt.toFixed(2)} sq ft</p>
                    <p>Total area: {lfTotalSqFt.toFixed(2)} sq ft</p>
                    <p className="text-[11px] text-slate-500">
                      Base cost / sq ft: ${lfBaseCostPerSqFt.toFixed(4)}
                    </p>
                    <p className="text-[11px] text-slate-500">
                      Price / sq ft (before qty discount): ${lfPricePerSqFtBeforeDiscount.toFixed(4)} ·
                      Qty discount: {lfAppliedDiscount}%
                    </p>
                    <p className="text-[11px] text-slate-500 mt-1">
                      Estimated total (before tax)
                    </p>
                    <p className="text-2xl font-extrabold text-blue-700">
                      ${lfTotalPrice.toFixed(2)}
                    </p>
                    <p className="text-xs text-gray-500 mt-2">
                      Preview and downloaded PDF use the same scaling logic.
                    </p>
                    <div className="mt-3 text-xs">
                      <div className="font-semibold mb-1">Add-ons</div>
                      {LF_ADDONS.map(a => (
                        <label key={a.key} className="flex items-center gap-2 mb-1">
                          <input
                            type="checkbox"
                            checked={!!lfAddonSelections[a.key]}
                            onChange={e =>
                              setLfAddonSelections(prev => ({
                                ...prev,
                                [a.key]: e.target.checked
                              }))
                            }
                          />
                          <span>{a.label}</span>
                          <span className="ml-auto">
                            ${Number(lfAddonPricing[a.key] || 0).toFixed(2)} / print
                          </span>
                        </label>
                      ))}
                    </div>
                    <div className="flex gap-3 mt-3">
                      <button
                        type="button"
                        onClick={downloadLargeFormatPDF}
                        className="bg-blue-500 text-white px-4 py-2 rounded-full text-xs shadow-sm"
                      >
                        Download Large Format (PDF)
                      </button>
                      <button
                        type="button"
                        onClick={() => handleStartOrder('large')}
                        className="bg-emerald-600 text-white px-4 py-2 rounded-full text-xs shadow-sm hover:bg-emerald-500 transition"
                      >
                        Order Large Format – Send to Store
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </>
          )}

          {/* QUICK QUOTE VIEW */}
          {viewMode === 'quote' && (
            <div className="space-y-6">
              <div>
                <h2 className="text-lg font-semibold mb-1">Quick Quote</h2>
                <p className="text-xs text-slate-500">
                  Get an instant estimate for your job across all available sheet sizes and paper types.
                  Uses your current pricing settings.
                </p>
              </div>

              <div className="grid md:grid-cols-2 gap-6 items-start">
                {/* Quote inputs */}
                <div className="space-y-4 text-sm">
                  <div className="bg-slate-50 border border-slate-200 rounded-2xl p-4 space-y-3">
                    <h3 className="font-semibold text-sm">Target Print Details</h3>
                    <div className="flex flex-wrap gap-3">
                      <div>
                        <label className="block text-xs font-medium">Print Width (in)</label>
                        <input
                          type="number"
                          min="0.1"
                          step="0.01"
                          value={quoteTarget.width}
                          onChange={e =>
                            setQuoteTarget(t => ({ ...t, width: +e.target.value || 0 }))
                          }
                          className="border p-1 w-24 rounded"
                        />
                      </div>
                      <div>
                        <label className="block text-xs font-medium">Print Height (in)</label>
                        <input
                          type="number"
                          min="0.1"
                          step="0.01"
                          value={quoteTarget.height}
                          onChange={e =>
                            setQuoteTarget(t => ({ ...t, height: +e.target.value || 0 }))
                          }
                          className="border p-1 w-24 rounded"
                        />
                      </div>
                      <div>
                        <label className="block text-xs font-medium">Quantity</label>
                        <input
                          type="number"
                          min="1"
                          step="1"
                          value={quoteTarget.quantity}
                          onChange={e =>
                            setQuoteTarget(t => ({ ...t, quantity: +e.target.value || 0 }))
                          }
                          className="border p-1 w-24 rounded"
                        />
                      </div>
                    </div>

                    <div className="flex flex-wrap items-center gap-3 mt-2">
                      <div className="flex items-center gap-1 text-xs">
                        <span className="font-medium">Front:</span>
                        <button
                          type="button"
                          onClick={() =>
                            setQuoteTarget(t => ({ ...t, colorMode: 'color' }))
                          }
                          className={`px-2 py-1 border rounded ${
                            quoteTarget.colorMode === 'color'
                              ? 'bg-emerald-500 text-white'
                              : 'bg-white'
                          }`}
                        >
                          Color
                        </button>
                        <button
                          type="button"
                          onClick={() =>
                            setQuoteTarget(t => ({ ...t, colorMode: 'bw' }))
                          }
                          className={`px-2 py-1 border rounded ${
                            quoteTarget.colorMode === 'bw'
                              ? 'bg-slate-700 text-white'
                              : 'bg-white'
                          }`}
                        >
                          B/W
                        </button>
                      </div>

                      <div className="flex items-center gap-2 text-xs">
                        <label className="flex items-center">
                          <input
                            type="checkbox"
                            className="mr-1"
                            checked={quoteTarget.backEnabled}
                            onChange={e =>
                              setQuoteTarget(t => ({ ...t, backEnabled: e.target.checked }))
                            }
                          />
                          Back printing
                        </label>
                        {quoteTarget.backEnabled && (
                          <>
                            <span>Back mode:</span>
                            <button
                              type="button"
                              onClick={() =>
                                setQuoteTarget(t => ({ ...t, backColorMode: 'color' }))
                              }
                              className={`px-2 py-1 border rounded ${
                                quoteTarget.backColorMode === 'color'
                                  ? 'bg-emerald-500 text-white'
                                  : 'bg-white'
                              }`}
                            >
                              Color
                            </button>
                            <button
                              type="button"
                              onClick={() =>
                                setQuoteTarget(t => ({ ...t, backColorMode: 'bw' }))
                              }
                              className={`px-2 py-1 border rounded ${
                                quoteTarget.backColorMode === 'bw'
                                  ? 'bg-slate-700 text-white'
                                  : 'bg-white'
                              }`}
                            >
                              B/W
                            </button>
                          </>
                        )}
                      </div>

                      {quoteTarget.backEnabled && (
                        <div className="text-[11px] text-amber-700">
                          Back printing selected – pricing includes back-side factor (
                          {backSideFactor}).
                        </div>
                      )}
                    </div>
                  </div>

                  <div className="bg-slate-50 border border-slate-200 rounded-2xl p-4 space-y-3">
                    <h3 className="font-semibold text-sm">Front/Back Sheet Calculator</h3>
                    <p className="text-[11px] text-slate-500">
                      For multi-page documents: quickly estimate how many sheets are needed if
                      printing front only or front/back.
                    </p>
                    <div className="flex flex-wrap gap-3 items-end">
                      <div>
                        <label className="block text-xs font-medium">Total pages</label>
                        <input
                          type="number"
                          min="1"
                          step="1"
                          value={quoteDocPages}
                          onChange={e =>
                            setQuoteDocPages(+e.target.value || 0)
                          }
                          className="border p-1 w-24 rounded"
                        />
                      </div>
                      <div className="flex items-center gap-2 text-xs">
                        <label className="flex items-center">
                          <input
                            type="checkbox"
                            className="mr-1"
                            checked={quoteDoubleSided}
                            onChange={e => setQuoteDoubleSided(e.target.checked)}
                          />
                          Print front &amp; back
                        </label>
                      </div>
                    </div>
                    <p className="text-sm mt-1">
                      Sheets required:{' '}
                      <span className="font-semibold">{quoteSheetsForDoc}</span>
                    </p>
                  </div>
                </div>

                {/* Quote results */}
                <div className="space-y-4 text-sm">
                  <div className="bg-white border border-slate-200 rounded-2xl p-4">
                    <div className="flex items-center justify-between mb-2">
                      <div className="font-semibold text-sm">All sheet &amp; paper options</div>
                      <div className="text-[11px] text-slate-500">
                        Only combinations where the target size fits on the sheet are shown.
                      </div>
                    </div>
                    {sortedQuoteOptions.length ? (
                      <div className="overflow-auto max-h-80">
                        <table className="min-w-full text-xs">
                          <thead className="bg-slate-50">
                            <tr>
                              <th className="px-2 py-1 text-left">Sheet</th>
                              <th className="px-2 py-1 text-left">Orientation</th>
                              <th className="px-2 py-1 text-left">Paper</th>
                              <th className="px-2 py-1 text-right">Prints / sheet</th>
                              <th className="px-2 py-1 text-right">Sheets needed</th>
                              <th className="px-2 py-1 text-right">Disc %</th>
                              <th className="px-2 py-1 text-right">Price / sheet</th>
                              <th className="px-2 py-1 text-right">Total</th>
                            </tr>
                          </thead>
                          <tbody>
                            {sortedQuoteOptions.map((opt, idx) => {
                              const isRecommended =
                                recommendedQuote &&
                                opt.sheetKey === recommendedQuote.sheetKey &&
                                opt.paperKey === recommendedQuote.paperKey &&
                                opt.orientation === recommendedQuote.orientation &&
                                Math.abs(opt.totalPrice - recommendedQuote.totalPrice) < 0.01;

                              return (
                                <tr
                                  key={idx}
                                  className={
                                    'border-t ' +
                                    (isRecommended
                                      ? 'bg-emerald-50/70'
                                      : idx % 2 === 0
                                      ? 'bg-white'
                                      : 'bg-slate-50/40')
                                  }
                                >
                                  <td className="px-2 py-1">
                                    {opt.sheetKey}
                                    {isRecommended && (
                                      <span className="ml-1 text-[10px] text-emerald-700 font-semibold">
                                        Best
                                      </span>
                                    )}
                                  </td>
                                  <td className="px-2 py-1 capitalize">{opt.orientation}</td>
                                  <td className="px-2 py-1">{opt.paperLabel}</td>
                                  <td className="px-2 py-1 text-right">
                                    {opt.printsPerSheet}
                                  </td>
                                  <td className="px-2 py-1 text-right">
                                    {opt.sheetsNeeded}
                                  </td>
                                  <td className="px-2 py-1 text-right">
                                    {opt.discount}%
                                  </td>
                                  <td className="px-2 py-1 text-right">
                                    ${opt.pricePerSheet.toFixed(4)}
                                  </td>
                                  <td className="px-2 py-1 text-right">
                                    ${opt.totalPrice.toFixed(2)}
                                  </td>
                                </tr>
                              );
                            })}
                          </tbody>
                        </table>
                      </div>
                    ) : (
                      <p className="text-xs text-slate-500">
                        No valid combinations found. The target size may be too large to fit on
                        any configured sheet, or pricing is missing. Try adjusting the size or
                        configuring pricing in the Admin panel.
                      </p>
                    )}
                  </div>

                  {recommendedQuote && (
                    <div className="bg-emerald-50 border border-emerald-200 rounded-2xl p-4 text-sm">
                      <div className="font-semibold text-emerald-900 mb-1">Recommended</div>
                      <p className="text-xs text-emerald-900">
                        Based on your target size and quantity,{' '}
                        <span className="font-semibold">
                          {recommendedQuote.sheetKey} ({recommendedQuote.orientation})
                        </span>{' '}
                        on{' '}
                        <span className="font-semibold">
                          {recommendedQuote.paperLabel}
                        </span>{' '}
                        is currently the most economical option, at approximately{' '}
                        <span className="font-semibold">
                          ${recommendedQuote.totalPrice.toFixed(2)}
                        </span>{' '}
                        total (about ${recommendedQuote.pricePerSheet.toFixed(2)} per sheet).
                      </p>
                      {quoteTarget.backEnabled && (
                        <p className="text-[11px] text-emerald-800 mt-1">
                          Note: This quote includes back printing with multiplier{' '}
                          {backSideFactor}.
                        </p>
                      )}
                      <p className="text-[11px] text-emerald-800 mt-1">
                        This is an estimate only. Final price may vary after file review.
                      </p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* ADMIN PANEL */}
          {isAdmin && showAdmin && (
            <div className="mt-8 border-t pt-4">
              <h2 className="text-xl font-semibold mb-3">Admin Pricing Panel</h2>
              <p className="text-xs text-gray-600 mb-2">
                Password: <span className="font-mono">store4979</span>. Values are saved in this browser,
                and you can also export/import a JSON file for backup.
              </p>

              <div className="flex flex-wrap items-end gap-4 mb-6 text-xs">
                <div>
                  <label className="block text-xs font-medium">Export current pricing</label>
                  <button
                    type="button"
                    onClick={exportPricingJson}
                    className="mt-1 px-3 py-1.5 border rounded bg-white hover:bg-slate-50"
                  >
                    Download pricing JSON
                  </button>
                </div>
                <div>
                  <label className="block text-xs font-medium">Import pricing JSON</label>
                  <input
                    type="file"
                    accept="application/json"
                    onChange={e => {
                      const f = e.target.files[0];
                      if (f) importPricingJson(f);
                    }}
                    className="mt-1 border p-1 rounded bg-white"
                  />
                </div>
              </div>

              <div className="grid md:grid-cols-2 gap-6 mb-6 text-xs">
                <div className="space-y-3">
                  <h3 className="font-semibold text-sm">Sheet Markups</h3>
                  {PAPER_TYPES.map(pt => (
                    <div key={pt.key} className="flex items-center gap-2">
                      <span className="w-40">{pt.label}</span>
                      <input
                        type="number"
                        value={markupPerPaper[pt.key] ?? 0}
                        onChange={e =>
                          setMarkupPerPaper(prev => ({
                            ...prev,
                            [pt.key]: e.target.value
                          }))
                        }
                        className="border p-1 w-20 rounded"
                      />
                      <span>%</span>
                      <button
                        type="button"
                        onClick={() => applyMarkupForPaper(pt.key)}
                        className="px-2 py-1 border rounded bg-blue-500 text-white text-xs"
                      >
                        Apply
                      </button>
                    </div>
                  ))}
                  <button
                    type="button"
                    onClick={applyMarkupForAllPapers}
                    className="mt-2 px-3 py-1.5 border rounded bg-blue-600 text-white text-xs"
                  >
                    Apply markup to all sheet papers
                  </button>
                </div>

                <div className="space-y-3">
                  <h3 className="font-semibold text-sm">Large Format Markups</h3>
                  {LF_PAPER_TYPES.map(pt => (
                    <div key={pt.key} className="flex items-center gap-2">
                      <span className="w-56">{pt.label}</span>
                      <input
                        type="number"
                        value={lfMarkupPerPaper[pt.key] ?? 0}
                        onChange={e =>
                          setLfMarkupPerPaper(prev => ({
                            ...prev,
                            [pt.key]: e.target.value
                          }))
                        }
                        className="border p-1 w-20 rounded"
                      />
                      <span>%</span>
                      <button
                        type="button"
                        onClick={() => applyLfMarkupForPaper(pt.key)}
                        className="px-2 py-1 border rounded bg-blue-500 text-white text-xs"
                      >
                        Apply
                      </button>
                    </div>
                  ))}
                  <button
                    type="button"
                    onClick={applyLfMarkupForAll}
                    className="mt-2 px-3 py-1.5 border rounded bg-blue-600 text-white text-xs"
                  >
                    Apply markup to all large format papers
                  </button>
                </div>
              </div>

              <div className="grid md:grid-cols-2 gap-6 mb-6 text-xs">
                <div>
                  <h3 className="font-semibold text-sm mb-1">Sheet Quantity Discounts</h3>
                  <p className="text-[11px] text-slate-500 mb-2">
                    Best matching discount is applied based on total sheets.
                  </p>
                  <table className="min-w-full text-xs border rounded overflow-hidden">
                    <thead className="bg-gray-100">
                      <tr>
                        <th className="px-2 py-1 text-left">Min Sheets</th>
                        <th className="px-2 py-1 text-left">Discount %</th>
                        <th />
                      </tr>
                    </thead>
                    <tbody>
                      {quantityDiscounts.map((tier, idx) => (
                        <tr key={idx} className="border-t">
                          <td className="px-2 py-1">
                            <input
                              type="number"
                              value={tier.minSheets}
                              onChange={e => {
                                const v = Number(e.target.value) || 0;
                                setQuantityDiscounts(prev => {
                                  const copy = [...prev];
                                  copy[idx] = { ...copy[idx], minSheets: v };
                                  return copy;
                                });
                              }}
                              className="border p-1 w-24 rounded"
                            />
                          </td>
                          <td className="px-2 py-1">
                            <input
                              type="number"
                              value={tier.discountPercent}
                              onChange={e => {
                                const v = Number(e.target.value) || 0;
                                setQuantityDiscounts(prev => {
                                  const copy = [...prev];
                                  copy[idx] = { ...copy[idx], discountPercent: v };
                                  return copy;
                                });
                              }}
                              className="border p-1 w-24 rounded"
                            />
                          </td>
                          <td className="px-2 py-1 text-right">
                            {quantityDiscounts.length > 1 && (
                              <button
                                type="button"
                                className="text-red-500 text-xs"
                                onClick={() =>
                                  setQuantityDiscounts(prev => prev.filter((_, i) => i !== idx))
                                }
                              >
                                Remove
                              </button>
                            )}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  <button
                    type="button"
                    className="mt-2 px-3 py-1.5 border rounded bg-white text-xs"
                    onClick={() =>
                      setQuantityDiscounts(prev => [...prev, { minSheets: 0, discountPercent: 0 }])
                    }
                  >
                    Add tier
                  </button>
                </div>

                <div>
                  <h3 className="font-semibold text-sm mb-1">Large Format Quantity Discounts</h3>
                  <p className="text-[11px] text-slate-500 mb-2">
                    Best matching discount is applied based on total square footage.
                  </p>
                  <table className="min-w-full text-xs border rounded overflow-hidden">
                    <thead className="bg-gray-100">
                      <tr>
                        <th className="px-2 py-1 text-left">Min Sq Ft</th>
                        <th className="px-2 py-1 text-left">Discount %</th>
                        <th />
                      </tr>
                    </thead>
                    <tbody>
                      {lfQuantityDiscounts.map((tier, idx) => (
                        <tr key={idx} className="border-t">
                          <td className="px-2 py-1">
                            <input
                              type="number"
                              value={tier.minSqFt}
                              onChange={e => {
                                const v = Number(e.target.value) || 0;
                                setLfQuantityDiscounts(prev => {
                                  const copy = [...prev];
                                  copy[idx] = { ...copy[idx], minSqFt: v };
                                  return copy;
                                });
                              }}
                              className="border p-1 w-24 rounded"
                            />
                          </td>
                          <td className="px-2 py-1">
                            <input
                              type="number"
                              value={tier.discountPercent}
                              onChange={e => {
                                const v = Number(e.target.value) || 0;
                                setLfQuantityDiscounts(prev => {
                                  const copy = [...prev];
                                  copy[idx] = { ...copy[idx], discountPercent: v };
                                  return copy;
                                });
                              }}
                              className="border p-1 w-24 rounded"
                            />
                          </td>
                          <td className="px-2 py-1 text-right">
                            {lfQuantityDiscounts.length > 1 && (
                              <button
                                type="button"
                                className="text-red-500 text-xs"
                                onClick={() =>
                                  setLfQuantityDiscounts(prev =>
                                    prev.filter((_, i) => i !== idx)
                                  )
                                }
                              >
                                Remove
                              </button>
                            )}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  <button
                    type="button"
                    className="mt-2 px-3 py-1.5 border rounded bg-white text-xs"
                    onClick={() =>
                      setLfQuantityDiscounts(prev => [
                        ...prev,
                        { minSqFt: 0, discountPercent: 0 }
                      ])
                    }
                  >
                    Add tier
                  </button>
                </div>
              </div>

              <div className="mt-4 flex flex-wrap gap-6 text-xs">
                <div>
                  <h3 className="font-semibold text-sm mb-1">Back-side Multiplier</h3>
                  <p className="text-[11px] text-slate-500 mb-1">
                    For back printing, price = front + (back × multiplier).
                  </p>
                  <div className="flex items-center gap-2">
                    <span>Multiplier:</span>
                    <input
                      type="number"
                      step="0.01"
                      value={backSideFactor}
                      onChange={e => setBackSideFactor(Number(e.target.value) || 0)}
                      className="border p-1 w-20 rounded"
                    />
                    <span className="text-[11px] text-slate-500">
                      e.g. 0.5 means back side adds 50% of front price.
                    </span>
                  </div>
                </div>

                <div>
                  <h3 className="font-semibold text-sm mb-1">Large Format Add-on Pricing</h3>
                  <table className="text-xs border rounded overflow-hidden">
                    <thead className="bg-gray-100">
                      <tr>
                        <th className="px-2 py-1 text-left">Add-on</th>
                        <th className="px-2 py-1 text-left">Price / print</th>
                      </tr>
                    </thead>
                    <tbody>
                      {LF_ADDONS.map(a => (
                        <tr key={a.key} className="border-t">
                          <td className="px-2 py-1">{a.label}</td>
                          <td className="px-2 py-1">
                            <input
                              type="number"
                              step="0.01"
                              value={lfAddonPricing[a.key] ?? 0}
                              onChange={e => {
                                const v = Number(e.target.value) || 0;
                                setLfAddonPricing(prev => ({
                                  ...prev,
                                  [a.key]: v
                                }));
                              }}
                              className="border p-1 w-24 rounded"
                            />
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          )}

          {/* ORDER MODAL */}
          {showOrderForm && (
            <div className="fixed inset-0 bg-black/30 flex items-center justify-center z-50">
              <div className="bg-white rounded-2xl shadow-xl p-5 w-full max-w-md space-y-4">
                <h3 className="text-lg font-semibold">
                  Order Details ({orderJobType === 'sheet' ? 'Sheet Prints' : 'Large Format'})
                </h3>
                <p className="text-xs text-slate-500">
                  Please enter your contact info so we can confirm your order and payment.
                </p>
                <div className="space-y-3 text-sm">
                  <div>
                    <label className="block text-xs font-medium">Name</label>
                    <input
                      type="text"
                      value={customerInfo.name}
                      onChange={e =>
                        setCustomerInfo(prev => ({ ...prev, name: e.target.value }))
                      }
                      className="border p-1 w-full rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-xs font-medium">Email</label>
                    <input
                      type="email"
                      value={customerInfo.email}
                      onChange={e =>
                        setCustomerInfo(prev => ({ ...prev, email: e.target.value }))
                      }
                      className="border p-1 w-full rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-xs font-medium">Phone</label>
                    <input
                      type="tel"
                      value={customerInfo.phone}
                      onChange={e =>
                        setCustomerInfo(prev => ({ ...prev, phone: e.target.value }))
                      }
                      className="border p-1 w-full rounded"
                    />
                  </div>
                </div>
                <div className="flex justify-between items-center mt-4">
                  <button
                    type="button"
                    onClick={() => setShowOrderForm(false)}
                    className="text-xs text-slate-600 hover:text-slate-900"
                    disabled={orderSending}
                  >
                    Cancel
                  </button>
                  <button
                    type="button"
                    onClick={() =>
                      orderJobType === 'sheet'
                        ? sendOrderEmail('sheet', buildSheetPdf)
                        : sendOrderEmail('large', buildLargeFormatPdf)
                    }
                    className="bg-emerald-600 text-white px-4 py-2 rounded-full text-xs shadow-sm disabled:opacity-60"
                    disabled={orderSending}
                  >
                    {orderSending ? 'Sending…' : 'Send Order to Store'}
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<PriceCalculatorApp />);
  </script>
</body>
</html>
