<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Print Price Calculator</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 p-8">
  <div id="root" class="max-w-6xl mx-auto"></div>

  <!-- React, ReactDOM, jsPDF, pdfjsLib, Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;
    const { jsPDF } = window.jspdf;

    // Preset sheet dimensions (inches)
    const PRESET_SHEETS = {
      "8.5x11": [8.5, 11],
      "11x17": [11, 17],
      "12x18": [12, 18],
      custom: null
    };

    const DPI = 300;
    const MARGIN_IN = 0.1;
    const SPACING_IN = 0.05;
    const BLEED_IN = 0.125; // 1/8" bleed for sheet jobs
    const LARGE_FORMAT_MAX_WIDTH = 36; // max custom width in large-format mode

    // Sheet Paper types
    const SHEET_PAPER_TYPES = [
      { key: '28lb', label: '28 LB Paper' },
      { key: '20lb', label: '20 LB Paper' },
      { key: '80c', label: '80 LB Cardstock Cover' },
      { key: '110c', label: '110 LB Cardstock Cover' },
      { key: '80t', label: '80 LB Text Gloss' },
      { key: '100t', label: '100 LB Text Gloss' },
      { key: '14pt', label: '14PT Gloss' },
      { key: '18pt', label: '18PT Gloss' }
    ];

    // Rules: all paper options are 8.5x11 and 11x17 EXCEPT 14PT/18PT which are only 12x18
    const SHEET_KEYS_FOR_PAPER = {
      '28lb': ['8.5x11', '11x17'],
      '20lb': ['8.5x11', '11x17'],
      '80c': ['8.5x11', '11x17'],
      '110c': ['8.5x11', '11x17'],
      '80t': ['8.5x11', '11x17'],
      '100t': ['8.5x11', '11x17'],
      '14pt': ['12x18'],
      '18pt': ['12x18']
    };

    // Large format paper types
    const LARGE_FORMAT_PAPERS = [
      { key: "hp_super_matte", label: "HP Super Heavyweight Plus Matte Paper" },
      { key: "hp_gloss_photo", label: "HP Universal Instant-dry Gloss Photo Paper" },
      { key: "plain_20lb", label: "20lb Plain bond paper" },
      { key: "lexjet_46_bond", label: "LexJet #46 Bond Paper (Bright White Bond Paper)" },
      { key: "lexjet_thrifty_banner", label: "LexJet TOUGHcoat™ ThriftyBanner (Heavyweight Coated Paper*)" },
      { key: "lexjet_polypro", label: "LexJet TOUGHcoat™ Water-Resistant Polypropylene (Matte Polypropylene v2*)" },
      { key: "fredrix_canvas", label: "Fredrix 777VWR Vivid Matte Canvas (Photo Matte Paper)" },
      { key: "hp_adhesive_polypro", label: "HP Everyday Adhesive Matte Polypropylene" },
      { key: "hp_translucent_bond", label: "HP Translucent Bond Paper (Transparent/Clear Film)" }
    ];

    const buildInitialSheetPricing = () => {
      const pricing = {};
      SHEET_PAPER_TYPES.forEach(pt => {
        pricing[pt.key] = {};
        (SHEET_KEYS_FOR_PAPER[pt.key] || []).forEach(sheetKey => {
          pricing[pt.key][sheetKey] = {
            baseCostColor: 0,
            baseCostBW: 0,
            priceColor: 0,
            priceBW: 0
          };
        });
      });
      return pricing;
    };

    const buildInitialLfPricing = () => {
      const pricing = {};
      LARGE_FORMAT_PAPERS.forEach(pt => {
        pricing[pt.key] = {
          baseCostPerSqFt: 0,
          pricePerSqFt: 0
        };
      });
      return pricing;
    };

    // ---- Helpers for PDF & email ----
    const MAX_EMAIL_BASE64_LEN = 6000000; // ~4–5 MB of base64, under Netlify body limit

    const pdfToBase64 = (pdf) => {
      return new Promise((resolve, reject) => {
        try {
          const blob = pdf.output('blob');
          const reader = new FileReader();
          reader.onloadend = () => {
            try {
              const result = reader.result || '';
              const commaIndex = result.indexOf(',');
              const base64 = commaIndex >= 0 ? result.slice(commaIndex + 1) : result;
              if (!base64) {
                return reject(new Error('Empty base64 from PDF'));
              }
              resolve(base64);
            } catch (e) {
              reject(e);
            }
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        } catch (e) {
          reject(e);
        }
      });
    };

    // Downscale a canvas before embedding in email PDF to keep file small
    const canvasToDataUrlScaled = (sourceCanvas, maxSize = 1400) => {
      if (!sourceCanvas) return null;
      const width = sourceCanvas.width;
      const height = sourceCanvas.height;
      if (!width || !height) return null;

      const maxDim = Math.max(width, height);
      const scale = maxDim > maxSize ? maxSize / maxDim : 1;

      if (scale >= 1) {
        // Just export as JPEG to compress a bit
        return sourceCanvas.toDataURL('image/jpeg', 0.8);
      }

      const c = document.createElement('canvas');
      c.width = Math.round(width * scale);
      c.height = Math.round(height * scale);
      const ctx = c.getContext('2d');
      ctx.drawImage(sourceCanvas, 0, 0, c.width, c.height);
      return c.toDataURL('image/jpeg', 0.8);
    };

    const sendOrderEmail = async (jobType, details, pdf) => {
      try {
        const base64Pdf = await pdfToBase64(pdf);
        console.log('pdfBase64 length (client):', base64Pdf.length);

        if (base64Pdf.length > MAX_EMAIL_BASE64_LEN) {
          alert(
            'Order file is too large to send automatically.\n\n' +
            'Please use the Download button and email the PDF manually to store4979@theupsstore.com.'
          );
          return;
        }

        const res = await fetch('/.netlify/functions/send-print-job', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            subject: 'PRINT JOB',
            to: 'store4979@theupsstore.com',
            jobType,
            details,
            pdfBase64: base64Pdf
          })
        });

        const text = await res.text();

        if (!res.ok) {
          console.error('Server error:', res.status, text);
          alert(
            'Server error while sending order:\n\n' +
            text +
            '\n\nPlease download the PDF and email it manually to store4979@theupsstore.com.'
          );
          return;
        }

        console.log('Order sent OK:', text);
        alert('Order sent! The store will receive your PRINT JOB email.');
      } catch (err) {
        console.error('sendOrderEmail error:', err);
        alert(
          'Could not send order automatically. Please download the PDF and email it to store4979@theupsstore.com.'
        );
      }
    };

    // ---- Main App ----
    function PriceCalculatorApp() {
      const [sheetKey, setSheetKey] = useState('8.5x11');
      const [customSize, setCustomSize] = useState({ w: 8.5, h: 11 }); // inches
      const [orientation, setOrientation] = useState('portrait');
      const [prints, setPrints] = useState({ width: 5, height: 7, quantity: 2 });

      // FRONT/BACK image or PDF-derived image
      const [frontFileList, setFrontFileList] = useState([]);
      const [frontRotation, setFrontRotation] = useState(0);
      const [backFileList, setBackFileList] = useState([]);
      const [backRotation, setBackRotation] = useState(0);
      const [showBack, setShowBack] = useState(false);
      const [showGuides, setShowGuides] = useState(true);
      const [showCutLines, setShowCutLines] = useState(true);
      const [bleedEnabled, setBleedEnabled] = useState(false);

      // Multi-page layout mode for PDFs: "1-1" or "1-2"
      const [multiPageLayout, setMultiPageLayout] = useState("1-2");

      // Color mode
      const [colorModeFront, setColorModeFront] = useState("color");
      const [colorModeBack, setColorModeBack] = useState("color");

      // Paper type selection
      const [paperKey, setPaperKey] = useState(SHEET_PAPER_TYPES[0].key);

      // Admin / pricing state for SHEET printing
      const [sheetPricing, setSheetPricing] = useState(buildInitialSheetPricing);
      const [sheetMarkupPerPaper, setSheetMarkupPerPaper] = useState(() => {
        const init = {};
        SHEET_PAPER_TYPES.forEach(pt => { init[pt.key] = 0; });
        return init;
      });

      // Large format state
      const [largeFormatEnabled, setLargeFormatEnabled] = useState(false);
      const [largeFormatPaperKey, setLargeFormatPaperKey] = useState(LARGE_FORMAT_PAPERS[0].key);
      const [largeFormatSize, setLargeFormatSize] = useState({ w: 24, h: 36 });
      const [largeFormatKeepProportions, setLargeFormatKeepProportions] = useState(true);
      const [largeFormatFiles, setLargeFormatFiles] = useState([]);
      const [largeFormatRotation, setLargeFormatRotation] = useState(0);

      const [lfPricing, setLfPricing] = useState(buildInitialLfPricing);
      const [lfMarkupPerPaper, setLfMarkupPerPaper] = useState(() => {
        const init = {};
        LARGE_FORMAT_PAPERS.forEach(pt => { init[pt.key] = 0; });
        return init;
      });

      // Quantity discounts
      const [sheetQtyDiscounts, setSheetQtyDiscounts] = useState([]);
      const [lfQtyDiscounts, setLfQtyDiscounts] = useState([]);

      // Back page cost behavior
      const [backPageCostMode, setBackPageCostMode] = useState("half");
      const [backPageCostIsAdminEnabled, setBackPageCostIsAdminEnabled] = useState(true);

      // Admin view
      const [isAdmin, setIsAdmin] = useState(false);
      const [showAdmin, setShowAdmin] = useState(false);

      // JSON pricing import/export
      const [pricingLoadError, setPricingLoadError] = useState("");

      // PDF-specific state
      const [frontPdfData, setFrontPdfData] = useState(null);
      const [frontPdfPages, setFrontPdfPages] = useState(0);
      const [backPdfData, setBackPdfData] = useState(null);
      const [backPdfPages, setBackPdfPages] = useState(0);

      const frontRef = useRef();
      const backRef = useRef();
      const sheetHighlightRef = useRef(null);
      const lfRef = useRef();

      // ---- LocalStorage Auto-save ----
      useEffect(() => {
        try {
          const storedSheet = window.localStorage.getItem("printCalcSheetPricing");
          const storedLf = window.localStorage.getItem("printCalcLfPricing");
          const storedSheetDisc = window.localStorage.getItem("printCalcSheetDiscounts");
          const storedLfDisc = window.localStorage.getItem("printCalcLfDiscounts");
          if (storedSheet) setSheetPricing(JSON.parse(storedSheet));
          if (storedLf) setLfPricing(JSON.parse(storedLf));
          if (storedSheetDisc) setSheetQtyDiscounts(JSON.parse(storedSheetDisc));
          if (storedLfDisc) setLfQtyDiscounts(JSON.parse(storedLfDisc));
        } catch (e) {
          console.error("Failed to load pricing from localStorage", e);
        }
      }, []);

      useEffect(() => {
        try {
          window.localStorage.setItem("printCalcSheetPricing", JSON.stringify(sheetPricing));
        } catch (e) {
          console.error("Failed to save sheet pricing", e);
        }
      }, [sheetPricing]);

      useEffect(() => {
        try {
          window.localStorage.setItem("printCalcLfPricing", JSON.stringify(lfPricing));
        } catch (e) {
          console.error("Failed to save LF pricing", e);
        }
      }, [lfPricing]);

      useEffect(() => {
        try {
          window.localStorage.setItem("printCalcSheetDiscounts", JSON.stringify(sheetQtyDiscounts));
        } catch (e) {
          console.error("Failed to save sheet discounts", e);
        }
      }, [sheetQtyDiscounts]);

      useEffect(() => {
        try {
          window.localStorage.setItem("printCalcLfDiscounts", JSON.stringify(lfQtyDiscounts));
        } catch (e) {
          console.error("Failed to save LF discounts", e);
        }
      }, [lfQtyDiscounts]);

      // Auto-load pricing.json once
      useEffect(() => {
        const loadJSONPricing = async () => {
          try {
            const res = await fetch('/pricing.json', { method: 'GET' });
            if (!res.ok) {
              console.warn("No pricing.json found or cannot load:", res.status);
              return;
            }
            const data = await res.json();
            applyPricingJSON(data);
            console.log("pricing.json auto-loaded and applied.");
          } catch (err) {
            console.warn("Failed to auto-load pricing.json", err);
          }
        };
        loadJSONPricing();
      }, []);

      const applyPricingJSON = (data) => {
        try {
          if (data.sheetPricing) setSheetPricing(data.sheetPricing);
          if (data.lfPricing) setLfPricing(data.lfPricing);
          if (data.sheetQtyDiscounts) setSheetQtyDiscounts(data.sheetQtyDiscounts);
          if (data.lfQtyDiscounts) setLfQtyDiscounts(data.lfQtyDiscounts);
          if (data.sheetMarkupPerPaper) setSheetMarkupPerPaper(data.sheetMarkupPerPaper);
          if (data.lfMarkupPerPaper) setLfMarkupPerPaper(data.lfMarkupPerPaper);
          setPricingLoadError("");
        } catch (e) {
          console.error("Error applying pricing JSON", e);
          setPricingLoadError("Error applying pricing JSON. Check console.");
        }
      };

      // ---- Utility: get current sheet size (inches) ----
      const getSheetInches = () => {
        if (sheetKey === 'custom') {
          let w = Math.max(0.1, Number(customSize.w) || 0);
          let h = Math.max(0.1, Number(customSize.h) || 0);
          if (largeFormatEnabled && w > LARGE_FORMAT_MAX_WIDTH) w = LARGE_FORMAT_MAX_WIDTH;
          return [w, h];
        }
        return PRESET_SHEETS[sheetKey];
      };

      const currentSheetPaper = SHEET_PAPER_TYPES.find(pt => pt.key === paperKey) || SHEET_PAPER_TYPES[0];
      const comboAllowed = (SHEET_KEYS_FOR_PAPER[paperKey] || []).includes(sheetKey) || sheetKey === 'custom';

      // Highlight animation when sheet changes
      useEffect(() => {
        if (sheetHighlightRef.current) {
          sheetHighlightRef.current.classList.remove("ring-2", "ring-yellow-400");
          void sheetHighlightRef.current.offsetWidth;
          sheetHighlightRef.current.classList.add("ring-2", "ring-yellow-400");
          const t = setTimeout(() => {
            sheetHighlightRef.current &&
              sheetHighlightRef.current.classList.remove("ring-2", "ring-yellow-400");
          }, 600);
          return () => clearTimeout(t);
        }
      }, [sheetKey]);

      // Sheet markup helpers
      const applySheetMarkupForPaper = (pk) => {
        const m = parseFloat(sheetMarkupPerPaper[pk]) || 0;
        const factor = 1 + m / 100;
        setSheetPricing(prev => {
          const next = { ...prev };
          const group = prev[pk] || {};
          next[pk] = {};
          for (const sk in group) {
            const entry = group[sk];
            next[pk][sk] = {
              ...entry,
              priceColor: parseFloat((entry.baseCostColor * factor).toFixed(4)),
              priceBW: parseFloat((entry.baseCostBW * factor).toFixed(4))
            };
          }
          return next;
        });
      };

      const applyLfMarkupForPaper = (pk) => {
        const m = parseFloat(lfMarkupPerPaper[pk]) || 0;
        const factor = 1 + m / 100;
        setLfPricing(prev => {
          const next = { ...prev };
          const entry = prev[pk] || { baseCostPerSqFt: 0, pricePerSqFt: 0 };
          next[pk] = {
            ...entry,
            pricePerSqFt: parseFloat((entry.baseCostPerSqFt * factor).toFixed(4))
          };
          return next;
        });
      };

      const handleAdminClick = () => {
        if (!isAdmin) {
          const pwd = window.prompt('Enter admin password');
          if (pwd === 'store4979') {
            setIsAdmin(true);
            setShowAdmin(true);
          } else {
            window.alert('Incorrect password');
          }
        } else {
          setShowAdmin(v => !v);
        }
      };

      // ---- Sheet imposition & pricing ----
      const [baseWIn, baseHIn] = getSheetInches();

      let sheetWIn = baseWIn;
      let sheetHIn = baseHIn;
      if (orientation === 'landscape') {
        [sheetWIn, sheetHIn] = [sheetHIn, sheetWIn];
      }

      const printW = Math.max(0.01, prints.width);
      const printH = Math.max(0.01, prints.height);

      const bleedExtra = bleedEnabled ? BLEED_IN * 2 : 0;
      const slotW = printW + bleedExtra;
      const slotH = printH + bleedExtra;

      const marginIn = MARGIN_IN;
      const spacingIn = SPACING_IN;

      const usableW = sheetWIn - 2 * marginIn;
      const usableH = sheetHIn - 2 * marginIn;

      const cols = Math.max(
        1,
        Math.floor((usableW + spacingIn) / (slotW + spacingIn))
      );
      const rows = Math.max(
        1,
        Math.floor((usableH + spacingIn) / (slotH + spacingIn))
      );

      const printsPerSheetExact = cols * rows;
      const printsPerSheet = Math.max(1, printsPerSheetExact);

      const requestedQty = Math.max(0, prints.quantity) || 0;
      const sheetsNeeded = requestedQty === 0
        ? 0
        : Math.ceil(requestedQty / printsPerSheet);

      // Quantity discount helpers
      const applySheetQtyDiscount = (basePrice, totalSheets) => {
        if (!sheetQtyDiscounts || sheetQtyDiscounts.length === 0) return basePrice;
        const sorted = [...sheetQtyDiscounts].sort((a, b) => b.minQty - a.minQty);
        let factor = 1;
        for (const disc of sorted) {
          if (totalSheets >= disc.minQty) {
            factor = 1 - (disc.discountPercent || 0) / 100;
            break;
          }
        }
        return basePrice * factor;
      };

      const applyLfQtyDiscount = (basePrice, totalSqFt) => {
        if (!lfQtyDiscounts || lfQtyDiscounts.length === 0) return basePrice;
        const sorted = [...lfQtyDiscounts].sort((a, b) => b.minQty - a.minQty);
        let factor = 1;
        for (const disc of sorted) {
          if (totalSqFt >= disc.minQty) {
            factor = 1 - (disc.discountPercent || 0) / 100;
            break;
          }
        }
        return basePrice * factor;
      };

      const selectedSheetPricing = (sheetPricing[paperKey] || {})[sheetKey] || {
        baseCostColor: 0,
        baseCostBW: 0,
        priceColor: 0,
        priceBW: 0
      };

      const pricePerSheetFront = colorModeFront === "color"
        ? (selectedSheetPricing.priceColor || 0)
        : (selectedSheetPricing.priceBW || 0);

      let backPerSheet = 0;
      if (showBack && backPageCostIsAdminEnabled) {
        const baseBack = colorModeBack === "color"
          ? (selectedSheetPricing.priceColor || 0)
          : (selectedSheetPricing.priceBW || 0);
        backPerSheet = backPageCostMode === "half" ? baseBack * 0.5 : baseBack;
      }

      const sheetPriceBeforeDiscount = (pricePerSheetFront + backPerSheet) * sheetsNeeded;
      const sheetTotal = applySheetQtyDiscount(sheetPriceBeforeDiscount, sheetsNeeded);
      const effectivePricePerSheet = sheetsNeeded > 0 ? sheetTotal / sheetsNeeded : 0;

      // ---- Drawing ----
      const fileToImageBitmap = (file) => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = URL.createObjectURL(file);
        });
      };

      const drawLayout = async (canvas, fileList, rotationDeg, isBack, colorModeSide) => {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        const wPx = sheetWIn * DPI;
        const hPx = sheetHIn * DPI;

        const marginPx = MARGIN_IN * DPI;
        const spacingPx = SPACING_IN * DPI;

        canvas.width = Math.round(wPx);
        canvas.height = Math.round(hPx);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!fileList || fileList.length === 0) return;

        const slotWPx = slotW * DPI;
        const slotHPx = slotH * DPI;
        const drawWPx = rotationDeg % 180 === 0 ? slotWPx : slotHPx;
        const drawHPx = rotationDeg % 180 === 0 ? slotHPx : slotWPx;

        const colsPx = cols;
        const rowsPx = rows;

        const totalWPx = colsPx * slotWPx + (colsPx - 1) * spacingPx;
        const totalHPx = rowsPx * slotHPx + (rowsPx - 1) * spacingPx;

        const offX = marginPx + (canvas.width - 2 * marginPx - totalWPx) / 2;
        const offY = marginPx + (canvas.height - 2 * marginPx - totalHPx) / 2;

        let count = 0;
        let firstX = null;
        let firstY = null;

        const maxSlots = colsPx * rowsPx;
        const neededPrints = Math.min(requestedQty || maxSlots, maxSlots);
        const allocatedPrints = neededPrints === 0 ? maxSlots : neededPrints;

        const allBitmaps = [];
        for (const f of fileList) {
          const img = await fileToImageBitmap(f);
          allBitmaps.push(img);
        }

        const getImageForSlot = (slotIndex) => {
          if (multiPageLayout === "1-1") {
            const fi = Math.min(slotIndex, allBitmaps.length - 1);
            return allBitmaps[fi];
          } else {
            const pagePairIndex = Math.floor(slotIndex / 2);
            const fi = Math.min(pagePairIndex * 2, allBitmaps.length - 1);
            return allBitmaps[fi];
          }
        };

        const drawCutLines = (x, y, w, h) => {
          const lineLen = 10;
          const half = 3;
          ctx.save();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x - half, y);
          ctx.lineTo(x - half - lineLen, y);
          ctx.moveTo(x + w + half, y);
          ctx.lineTo(x + w + half + lineLen, y);
          ctx.moveTo(x - half, y + h);
          ctx.lineTo(x - half - lineLen, y + h);
          ctx.moveTo(x + w + half, y + h);
          ctx.lineTo(x + w + half + lineLen, y + h);
          ctx.stroke();
          ctx.restore();
        };

        const applyColorModeFilters = () => {
          if (colorModeSide === "bw") {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const d = imageData.data;
            for (let i = 0; i < d.length; i += 4) {
              const r = d[i];
              const g = d[i + 1];
              const b = d[i + 2];
              const gray = 0.3 * r + 0.59 * g + 0.11 * b;
              d[i] = d[i + 1] = d[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
          }
        };

        for (let r = 0; r < rowsPx && count < allocatedPrints; r++) {
          for (let c = 0; c < colsPx && count < allocatedPrints; c++) {
            const x = offX + c * (slotWPx + spacingPx);
            const y = offY + r * (slotHPx + spacingPx);

            if (firstX === null) {
              firstX = x;
              firstY = y;
            }

            const bmp = getImageForSlot(count % fileList.length);

            ctx.save();
            ctx.translate(x + drawWPx / 2, y + drawHPx / 2);
            ctx.rotate((rotationDeg * Math.PI) / 180);

            const targetWIn = printW + (bleedEnabled ? BLEED_IN * 2 : 0);
            const targetHIn = printH + (bleedEnabled ? BLEED_IN * 2 : 0);
            const targetWPx = targetWIn * DPI;
            const targetHPx = targetHIn * DPI;

            ctx.drawImage(
              bmp,
              -targetWPx / 2,
              -targetHPx / 2,
              targetWPx,
              targetHPx
            );

            ctx.restore();

            if (showCutLines) {
              drawCutLines(x, y, slotWPx, slotHPx);
            }

            count++;
          }
        }

        if (showGuides && firstX !== null) {
          ctx.save();
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;
          ctx.font = '12px sans-serif';

          const totalHPxWithImage = drawHPx;
          const leftDist = (firstX / DPI).toFixed(2) + ' in';
          const topDist = (firstY / DPI).toFixed(2) + ' in';

          const gap = 20;

          ctx.beginPath();
          ctx.moveTo(0, firstY + totalHPxWithImage + gap);
          ctx.lineTo(firstX, firstY + totalHPxWithImage + gap);
          ctx.stroke();
          const leftTextWidth = ctx.measureText(leftDist).width;
          ctx.fillText(
            leftDist,
            firstX / 2 - leftTextWidth / 2,
            firstY + totalHPxWithImage + gap - 4
          );

          ctx.beginPath();
          ctx.moveTo(firstX + drawWPx + gap, 0);
          ctx.lineTo(firstX + drawWPx + gap, firstY);
          ctx.stroke();
          ctx.fillText(
            topDist,
            firstX + drawWPx + gap + 4,
            firstY / 2 + 4
          );

          ctx.restore();
        }

        applyColorModeFilters();
      };

      useEffect(() => {
        (async () => {
          await drawLayout(frontRef.current, frontFileList, frontRotation, false, colorModeFront);
          if (showBack) {
            await drawLayout(backRef.current, backFileList, backRotation, true, colorModeBack);
          }
        })();
      }, [
        baseWIn,
        baseHIn,
        sheetWIn,
        sheetHIn,
        orientation,
        prints,
        frontFileList,
        frontRotation,
        backFileList,
        backRotation,
        showBack,
        showGuides,
        showCutLines,
        bleedEnabled,
        colorModeFront,
        colorModeBack,
        multiPageLayout,
        cols,
        rows
      ]);

      // ---- PDF helpers (for multi-page PDF -> image files) ----
      async function loadPdfToState(file, side) {
        const data = new Uint8Array(await file.arrayBuffer());
        const pdf = await pdfjsLib.getDocument({ data }).promise;
        const pages = pdf.numPages;
        const imgs = [];
        for (let i = 1; i <= pages; i++) {
          const f = await rasterizePdfPageToFile(data, i);
          imgs.push(f);
        }
        if (side === 'front') {
          setFrontPdfData(data);
          setFrontPdfPages(pages);
          setFrontFileList(imgs);
        } else {
          setBackPdfData(data);
          setBackPdfPages(pages);
          setBackFileList(imgs);
        }
      }

      async function rasterizePdfPageToFile(pdfData, pageNum) {
        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 3 });
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        c.width = viewport.width;
        c.height = viewport.height;
        await page.render({ canvasContext: ctx, viewport }).promise;
        return new Promise((resolve) => {
          c.toBlob(
            (blob) => resolve(new File([blob], `page-${pageNum}.png`, { type: 'image/png' })),
            'image/png',
            1.0
          );
        });
      }

      // ---- Large Format Drawing ----
      const drawLargeFormat = async () => {
        const canvas = lfRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        const wPx = largeFormatSize.w * DPI;
        const hPx = largeFormatSize.h * DPI;
        canvas.width = Math.round(wPx);
        canvas.height = Math.round(hPx);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!largeFormatFiles || largeFormatFiles.length === 0) return;

        const file = largeFormatFiles[0];
        const img = await fileToImageBitmap(file);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate((largeFormatRotation * Math.PI) / 180);

        const iw = img.width;
        const ih = img.height;
        let dw = wPx;
        let dh = hPx;

        if (largeFormatKeepProportions) {
          const imgRatio = iw / ih;
          const canvasRatio = wPx / hPx;
          if (imgRatio > canvasRatio) {
            dw = wPx;
            dh = wPx / imgRatio;
          } else {
            dh = hPx;
            dw = hPx * imgRatio;
          }
        }

        ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
        ctx.restore();
      };

      useEffect(() => {
        if (largeFormatEnabled) {
          drawLargeFormat();
        }
      }, [
        largeFormatEnabled,
        largeFormatSize,
        largeFormatFiles,
        largeFormatRotation,
        largeFormatKeepProportions
      ]);

      // Large format pricing
      const currentLfPricing = lfPricing[largeFormatPaperKey] || {
        baseCostPerSqFt: 0,
        pricePerSqFt: 0
      };

      const lfAreaSqFt = (largeFormatSize.w * largeFormatSize.h) / 144;
      const lfBasePrice = currentLfPricing.pricePerSqFt * lfAreaSqFt;
      const lfTotalPrice = applyLfQtyDiscount(lfBasePrice, lfAreaSqFt);

      // ---- Download PDF for sheet (full-res, print-ready) ----
      const downloadSheetPDF = () => {
        if (!frontFileList || frontFileList.length === 0) {
          alert("Please upload at least one front file before downloading.");
          return;
        }

        let pdfW = baseWIn;
        let pdfH = baseHIn;
        if (orientation === 'landscape') [pdfW, pdfH] = [baseHIn, baseWIn];

        const pdf = new jsPDF({
          orientation,
          unit: 'in',
          format: [pdfW, pdfH]
        });

        const frontData = frontRef.current.toDataURL('image/png', 1.0);
        pdf.addImage(frontData, 'PNG', 0, 0, pdfW, pdfH);

        if (showBack && backFileList && backFileList.length > 0) {
          pdf.addPage([pdfW, pdfH], orientation);
          const backData = backRef.current.toDataURL('image/png', 1.0);
          pdf.addImage(backData, 'PNG', 0, 0, pdfW, pdfH);
        }

        pdf.save('print_preview.pdf');
      };

      // ---- Order sheet job (compressed proof PDF for email) ----
      const orderSheetJob = async () => {
        if (!frontFileList || frontFileList.length === 0) {
          alert("Please upload at least one front file before ordering.");
          return;
        }

        let pdfW = baseWIn;
        let pdfH = baseHIn;
        if (orientation === 'landscape') [pdfW, pdfH] = [baseHIn, baseWIn];

        const pdf = new jsPDF({
          orientation,
          unit: 'in',
          format: [pdfW, pdfH]
        });

        const frontDataEmail = canvasToDataUrlScaled(frontRef.current, 1400);
        if (!frontDataEmail) {
          alert("Could not prepare preview image for email.");
          return;
        }
        pdf.addImage(frontDataEmail, 'JPEG', 0, 0, pdfW, pdfH);

        if (showBack && backFileList && backFileList.length > 0) {
          pdf.addPage([pdfW, pdfH], orientation);
          const backDataEmail = canvasToDataUrlScaled(backRef.current, 1400);
          if (!backDataEmail) {
            alert("Could not prepare back preview image for email.");
            return;
          }
          pdf.addImage(backDataEmail, 'JPEG', 0, 0, pdfW, pdfH);
        }

        const details = {
          type: "Sheet",
          sheetKey,
          customSize: sheetKey === "custom" ? customSize : null,
          orientation,
          prints,
          paper: currentSheetPaper.label,
          sheetsNeeded,
          colorModeFront,
          colorModeBack: showBack ? colorModeBack : null,
          bleedEnabled,
          totalPrice: sheetTotal,
          pricePerSheet: effectivePricePerSheet
        };

        await sendOrderEmail("sheet", details, pdf);
      };

      // ---- Download / Order Large Format ----
      const downloadLfPDF = () => {
        if (!largeFormatFiles || largeFormatFiles.length === 0) {
          alert("Please upload a large format image before downloading.");
          return;
        }
        const pdfW = largeFormatSize.w;
        const pdfH = largeFormatSize.h;

        const pdf = new jsPDF({
          orientation: pdfW >= pdfH ? "landscape" : "portrait",
          unit: "in",
          format: [pdfW, pdfH]
        });

        const imgData = lfRef.current.toDataURL('image/png', 1.0);
        pdf.addImage(imgData, 'PNG', 0, 0, pdfW, pdfH);
        pdf.save('large_format_preview.pdf');
      };

      const orderLfJob = async () => {
        if (!largeFormatFiles || largeFormatFiles.length === 0) {
          alert("Please upload a large format image before ordering.");
          return;
        }

        const pdfW = largeFormatSize.w;
        const pdfH = largeFormatSize.h;

        const pdf = new jsPDF({
          orientation: pdfW >= pdfH ? "landscape" : "portrait",
          unit: "in",
          format: [pdfW, pdfH]
        });

        const imgDataEmail = canvasToDataUrlScaled(lfRef.current, 2000);
        if (!imgDataEmail) {
          alert("Could not prepare large format preview image for email.");
          return;
        }

        pdf.addImage(imgDataEmail, 'JPEG', 0, 0, pdfW, pdfH);

        const details = {
          type: "Large Format",
          paper: LARGE_FORMAT_PAPERS.find(p => p.key === largeFormatPaperKey)?.label,
          size: largeFormatSize,
          keepProportions: largeFormatKeepProportions,
          rotation: largeFormatRotation,
          areaSqFt: lfAreaSqFt,
          totalPrice: lfTotalPrice
        };

        await sendOrderEmail("large-format", details, pdf);
      };

      // ---- Admin import/export pricing ----
      const handleExportPricing = () => {
        const data = {
          sheetPricing,
          lfPricing,
          sheetQtyDiscounts,
          lfQtyDiscounts,
          sheetMarkupPerPaper,
          lfMarkupPerPaper
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "pricing-export.json";
        a.click();
        URL.revokeObjectURL(url);
      };

      const handleImportPricingFile = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const parsed = JSON.parse(e.target.result);
            applyPricingJSON(parsed);
          } catch (err) {
            console.error("Failed to parse pricing JSON", err);
            setPricingLoadError("Invalid JSON file");
          }
        };
        reader.readAsText(file);
      };

      // ---- UI ----
      return (
        <div className="space-y-6">
          <div className="flex justify-between items-center">
            <h1 className="text-2xl font-bold">Print Layout & Pricing Tool</h1>
            <div className="flex items-center gap-2">
              <button
                type="button"
                onClick={handleAdminClick}
                className="px-3 py-1 border rounded text-sm bg-white"
              >
                {isAdmin ? (showAdmin ? 'Hide Admin' : 'Show Admin') : 'Admin / Pricing'}
              </button>
            </div>
          </div>

          {/* Sheet / Large format toggle */}
          <div className="flex gap-4 items-center">
            <label className="flex items-center gap-1 text-sm">
              <input
                type="checkbox"
                checked={largeFormatEnabled}
                onChange={(e) => setLargeFormatEnabled(e.target.checked)}
              />
              Use Large Format Mode
            </label>
          </div>

          {/* SHEET SECTION */}
          {!largeFormatEnabled && (
            <>
              <div
                ref={sheetHighlightRef}
                className="flex flex-wrap gap-4 items-end bg-white p-3 rounded border"
              >
                <div>
                  <label className="block text-sm font-medium">Base Sheet</label>
                  <select
                    value={sheetKey}
                    onChange={(e) => setSheetKey(e.target.value)}
                    className="border p-1"
                  >
                    <option value="8.5x11">8.5 × 11 in</option>
                    <option value="11x17">11 × 17 in</option>
                    <option value="12x18">12 × 18 in</option>
                    <option value="custom">Custom…</option>
                  </select>
                </div>

                {sheetKey === 'custom' && (
                  <div className="flex items-end gap-3">
                    <div>
                      <label className="block text-sm font-medium">Custom Width (in)</label>
                      <input
                        type="number"
                        min="0.1"
                        max={LARGE_FORMAT_MAX_WIDTH}
                        step="0.01"
                        value={customSize.w}
                        onChange={(e) =>
                          setCustomSize((s) => ({
                            ...s,
                            w: Math.min(+e.target.value || 0, LARGE_FORMAT_MAX_WIDTH)
                          }))
                        }
                        className="border p-1 w-28"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium">Custom Height (in)</label>
                      <input
                        type="number"
                        min="0.1"
                        step="0.01"
                        value={customSize.h}
                        onChange={(e) =>
                          setCustomSize((s) => ({ ...s, h: +e.target.value || 0 }))
                        }
                        className="border p-1 w-28"
                      />
                    </div>
                  </div>
                )}

                <div className="space-x-2">
                  <label className="text-sm font-medium mr-2">Orientation</label>
                  <button
                    onClick={() => setOrientation('portrait')}
                    className={`border p-1 ${
                      orientation === 'portrait' ? 'bg-white' : 'bg-gray-100'
                    }`}
                  >
                    Portrait
                  </button>
                  <button
                    onClick={() => setOrientation('landscape')}
                    className={`border p-1 ${
                      orientation === 'landscape' ? 'bg-white' : 'bg-gray-100'
                    }`}
                  >
                    Landscape
                  </button>
                </div>

                <div className="flex space-x-2 items-end">
                  <div>
                    <label className="block text-sm font-medium">Print W (in)</label>
                    <input
                      type="number"
                      value={prints.width}
                      onChange={(e) =>
                        setPrints((p) => ({ ...p, width: +e.target.value || 0 }))
                      }
                      className="border p-1 w-24"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Print H (in)</label>
                    <input
                      type="number"
                      value={prints.height}
                      onChange={(e) =>
                        setPrints((p) => ({ ...p, height: +e.target.value || 0 }))
                      }
                      className="border p-1 w-24"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Qty</label>
                    <input
                      type="number"
                      value={prints.quantity}
                      onChange={(e) =>
                        setPrints((p) => ({ ...p, quantity: +e.target.value || 0 }))
                      }
                      className="border p-1 w-20"
                    />
                  </div>
                </div>
              </div>

              {/* Paper type buttons */}
              <div className="space-y-2">
                <span className="block text-sm font-medium">Paper Type</span>
                <div className="flex flex-wrap gap-2">
                  {SHEET_PAPER_TYPES.map((opt) => (
                    <button
                      key={opt.key}
                      type="button"
                      onClick={() => setPaperKey(opt.key)}
                      className={`px-3 py-1 border rounded text-sm ${
                        paperKey === opt.key ? 'bg-blue-500 text-white' : 'bg-white'
                      }`}
                    >
                      {opt.label}
                    </button>
                  ))}
                </div>
                {!comboAllowed && (
                  <p className="text-xs text-red-600">
                    Note: {currentSheetPaper.label} is only supported on{' '}
                    {SHEET_KEYS_FOR_PAPER[paperKey].join(' or ')}.
                  </p>
                )}
              </div>

              <div className="flex flex-wrap gap-4 items-center">
                <label className="flex items-center gap-1 text-sm">
                  <input
                    type="checkbox"
                    checked={showGuides}
                    onChange={(e) => setShowGuides(e.target.checked)}
                  />
                  Show margin distances
                </label>
                <label className="flex items-center gap-1 text-sm">
                  <input
                    type="checkbox"
                    checked={showCutLines}
                    onChange={(e) => setShowCutLines(e.target.checked)}
                  />
                  Show cut lines
                </label>
                <label className="flex items-center gap-1 text-sm">
                  <input
                    type="checkbox"
                    checked={bleedEnabled}
                    onChange={(e) => setBleedEnabled(e.target.checked)}
                  />
                  Add 0.125" bleed
                </label>
                <label className="flex items-center gap-1 text-sm">
                  <span>Front mode:</span>
                  <select
                    value={colorModeFront}
                    onChange={(e) => setColorModeFront(e.target.value)}
                    className="border p-1 text-xs"
                  >
                    <option value="color">Color</option>
                    <option value="bw">B/W</option>
                  </select>
                </label>
                <label className="flex items-center gap-1 text-sm">
                  <span>Layout:</span>
                  <select
                    value={multiPageLayout}
                    onChange={(e) => setMultiPageLayout(e.target.value)}
                    className="border p-1 text-xs"
                  >
                    <option value="1-1">1 page per slot</option>
                    <option value="1-2">2 pages per sheet (1-2, 3-4...)</option>
                  </select>
                </label>
              </div>

              <div className="grid md:grid-cols-2 gap-6">
                {/* FRONT controls */}
                <div className="space-y-2">
                  <h2 className="font-semibold">Front</h2>
                  <div className="flex flex-wrap items-center gap-3">
                    <input
                      type="file"
                      accept="image/*,application/pdf"
                      multiple
                      onChange={async (e) => {
                        const files = Array.from(e.target.files || []);
                        if (!files.length) return;
                        const pdfs = files.filter(f => f.type === 'application/pdf');
                        const images = files.filter(f => f.type !== 'application/pdf');

                        const newList = [...frontFileList];

                        for (const img of images) newList.push(img);
                        if (pdfs.length) {
                          for (const pdfFile of pdfs) {
                            await loadPdfToState(pdfFile, 'front');
                          }
                        } else {
                          setFrontFileList(newList);
                        }
                      }}
                      className="border p-1"
                    />
                    <button
                      onClick={() => setFrontRotation((r) => r + 90)}
                      className="border p-1 text-sm"
                    >
                      Rotate 90°
                    </button>
                  </div>
                  <canvas ref={frontRef} className="w-full h-auto border bg-white" />
                </div>

                {/* BACK controls */}
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <h2 className="font-semibold">Back</h2>
                    <label className="text-sm">
                      <input
                        type="checkbox"
                        checked={showBack}
                        onChange={(e) => setShowBack(e.target.checked)}
                        className="mr-1"
                      />
                      Enable
                    </label>
                  </div>
                  {showBack && (
                    <>
                      <div className="flex flex-wrap items-center gap-3">
                        <input
                          type="file"
                          accept="image/*,application/pdf"
                          multiple
                          onChange={async (e) => {
                            const files = Array.from(e.target.files || []);
                            if (!files.length) return;
                            const pdfs = files.filter(f => f.type === 'application/pdf');
                            const images = files.filter(f => f.type !== 'application/pdf');

                            const newList = [...backFileList];

                            for (const img of images) newList.push(img);
                            if (pdfs.length) {
                              for (const pdfFile of pdfs) {
                                await loadPdfToState(pdfFile, 'back');
                              }
                            } else {
                              setBackFileList(newList);
                            }
                          }}
                          className="border p-1"
                        />
                        <button
                          onClick={() => setBackRotation((r) => r + 90)}
                          className="border p-1 text-sm"
                        >
                          Rotate 90°
                        </button>
                        <label className="flex items-center gap-1 text-sm">
                          <span>Back mode:</span>
                          <select
                            value={colorModeBack}
                            onChange={(e) => setColorModeBack(e.target.value)}
                            className="border p-1 text-xs"
                          >
                            <option value="color">Color</option>
                            <option value="bw">B/W</option>
                          </select>
                        </label>
                      </div>
                      <canvas ref={backRef} className="w-full h-auto border bg-white" />
                    </>
                  )}
                </div>
              </div>

              <div className="mt-4 flex items-center gap-6 flex-wrap">
                <div>
                  <p>Sheets Needed: {sheetsNeeded}</p>
                  <p className="text-sm text-gray-600">
                    Selected paper: {currentSheetPaper.label}
                  </p>
                  <p className="text-sm text-gray-600">
                    Effective price per sheet: ${effectivePricePerSheet.toFixed(2)}
                  </p>
                  <p className="font-semibold">Total price: ${sheetTotal.toFixed(2)}</p>
                </div>
                <button
                  onClick={downloadSheetPDF}
                  className="bg-blue-500 text-white px-4 py-2 rounded text-sm"
                >
                  Download Preview (PDF)
                </button>
                <button
                  onClick={orderSheetJob}
                  className="bg-green-600 text-white px-4 py-2 rounded text-sm"
                >
                  Order Prints (Sheet)
                </button>
              </div>
            </>
          )}

          {/* LARGE FORMAT SECTION */}
          {largeFormatEnabled && (
            <div className="space-y-4">
              <div className="bg-white p-3 rounded border space-y-3">
                <h2 className="font-semibold text-lg">Large Format Printing</h2>
                <div className="flex flex-wrap gap-4 items-end">
                  <div>
                    <label className="block text-sm font-medium">Paper Type</label>
                    <select
                      value={largeFormatPaperKey}
                      onChange={(e) => setLargeFormatPaperKey(e.target.value)}
                      className="border p-1"
                    >
                      {LARGE_FORMAT_PAPERS.map(p => (
                        <option key={p.key} value={p.key}>{p.label}</option>
                      ))}
                    </select>
                  </div>
                  <div className="flex gap-3 items-end">
                    <div>
                      <label className="block text-sm font-medium">Width (in)</label>
                      <input
                        type="number"
                        min="0.1"
                        max={LARGE_FORMAT_MAX_WIDTH}
                        step="0.01"
                        value={largeFormatSize.w}
                        onChange={(e) =>
                          setLargeFormatSize((s) => ({
                            ...s,
                            w: Math.min(+e.target.value || 0, LARGE_FORMAT_MAX_WIDTH)
                          }))
                        }
                        className="border p-1 w-24"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium">Height (in)</label>
                      <input
                        type="number"
                        min="0.1"
                        step="0.01"
                        value={largeFormatSize.h}
                        onChange={(e) =>
                          setLargeFormatSize((s) => ({ ...s, h: +e.target.value || 0 }))
                        }
                        className="border p-1 w-24"
                      />
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <label className="flex items-center gap-1 text-sm">
                      <input
                        type="checkbox"
                        checked={largeFormatKeepProportions}
                        onChange={(e) => setLargeFormatKeepProportions(e.target.checked)}
                      />
                      Keep image proportions
                    </label>
                    {!largeFormatKeepProportions && (
                      <span className="text-xs text-red-600">
                        Image may be stretched / distorted.
                      </span>
                    )}
                  </div>
                  <div>
                    <label className="block text-sm font-medium">Target Image</label>
                    <input
                      type="file"
                      accept="image/*"
                      onChange={async (e) => {
                        const file = e.target.files && e.target.files[0];
                        if (!file) return;
                        setLargeFormatFiles([file]);
                      }}
                      className="border p-1"
                    />
                  </div>
                  <button
                    onClick={() => setLargeFormatRotation((r) => r + 90)}
                    className="border p-1 text-sm"
                  >
                    Rotate 90°
                  </button>
                </div>
                <canvas ref={lfRef} className="w-full h-auto border bg-white" />
                <div className="flex items-center gap-6 flex-wrap mt-2">
                  <div>
                    <p className="text-sm text-gray-700">
                      Area: {lfAreaSqFt.toFixed(2)} sq ft
                    </p>
                    <p className="text-sm text-gray-700">
                      Price / sq ft: ${currentLfPricing.pricePerSqFt.toFixed(4)}
                    </p>
                    <p className="font-semibold">
                      Total price: ${lfTotalPrice.toFixed(2)}
                    </p>
                  </div>
                  <button
                    onClick={downloadLfPDF}
                    className="bg-blue-500 text-white px-4 py-2 rounded text-sm"
                  >
                    Download Large Format (PDF)
                  </button>
                  <button
                    onClick={orderLfJob}
                    className="bg-green-600 text-white px-4 py-2 rounded text-sm"
                  >
                    Order Prints (Large Format)
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* ADMIN PANEL */}
          {isAdmin && showAdmin && (
            <div className="mt-8 border-t pt-4 space-y-6">
              <h2 className="text-xl font-semibold mb-3">Admin Pricing Panel</h2>
              <p className="text-xs text-gray-600 mb-4">
                Values are stored in memory and in browser localStorage. You can also
                export/import as JSON.
              </p>

              <div className="flex flex-wrap gap-4 items-center">
                <div className="flex flex-col gap-1">
                  <span className="text-sm font-medium">Export / Import Pricing</span>
                  <div className="flex gap-2 items-center">
                    <button
                      type="button"
                      onClick={handleExportPricing}
                      className="px-3 py-1 border rounded bg-gray-100 text-sm"
                    >
                      Export JSON
                    </button>
                    <label className="text-sm flex items-center gap-1">
                      <span>Import JSON:</span>
                      <input
                        type="file"
                        accept="application/json"
                        onChange={(e) => {
                          const file = e.target.files && e.target.files[0];
                          if (file) handleImportPricingFile(file);
                        }}
                        className="border p-1 text-xs"
                      />
                    </label>
                  </div>
                  {pricingLoadError && (
                    <p className="text-xs text-red-600">{pricingLoadError}</p>
                  )}
                </div>
              </div>

              {/* Sheet pricing table */}
              <div className="space-y-3">
                <h3 className="font-semibold">Sheet Pricing</h3>
                <div className="overflow-auto max-h-96 border rounded">
                  <table className="min-w-full text-xs">
                    <thead className="bg-gray-100">
                      <tr>
                        <th className="px-2 py-1 text-left">Paper Type</th>
                        <th className="px-2 py-1 text-left">Sheet Size</th>
                        <th className="px-2 py-1 text-left">Base Color cost / sheet</th>
                        <th className="px-2 py-1 text-left">Base B/W cost / sheet</th>
                        <th className="px-2 py-1 text-left">Markup %</th>
                        <th className="px-2 py-1 text-left">Price Color / sheet</th>
                        <th className="px-2 py-1 text-left">Price B/W / sheet</th>
                      </tr>
                    </thead>
                    <tbody>
                      {SHEET_PAPER_TYPES.map(pt => (
                        (SHEET_KEYS_FOR_PAPER[pt.key] || []).map(sk => {
                          const entry = (sheetPricing[pt.key] || {})[sk] || {
                            baseCostColor: 0,
                            baseCostBW: 0,
                            priceColor: 0,
                            priceBW: 0
                          };
                          const mk = sheetMarkupPerPaper[pt.key] || 0;
                          return (
                            <tr key={pt.key + '-' + sk} className="border-t">
                              <td className="px-2 py-1">{pt.label}</td>
                              <td className="px-2 py-1">{sk}</td>
                              <td className="px-2 py-1">
                                <input
                                  type="number"
                                  step="0.0001"
                                  value={entry.baseCostColor}
                                  onChange={(e) => {
                                    const v = parseFloat(e.target.value) || 0;
                                    setSheetPricing(prev => {
                                      const next = { ...prev };
                                      next[pt.key] = { ...(prev[pt.key] || {}) };
                                      const old = (prev[pt.key] || {})[sk] || {
                                        baseCostColor: 0,
                                        baseCostBW: 0,
                                        priceColor: 0,
                                        priceBW: 0
                                      };
                                      next[pt.key][sk] = {
                                        ...old,
                                        baseCostColor: v
                                      };
                                      return next;
                                    });
                                  }}
                                  className="border p-1 w-20"
                                />
                              </td>
                              <td className="px-2 py-1">
                                <input
                                  type="number"
                                  step="0.0001"
                                  value={entry.baseCostBW}
                                  onChange={(e) => {
                                    const v = parseFloat(e.target.value) || 0;
                                    setSheetPricing(prev => {
                                      const next = { ...prev };
                                      next[pt.key] = { ...(prev[pt.key] || {}) };
                                      const old = (prev[pt.key] || {})[sk] || {
                                        baseCostColor: 0,
                                        baseCostBW: 0,
                                        priceColor: 0,
                                        priceBW: 0
                                      };
                                      next[pt.key][sk] = {
                                        ...old,
                                        baseCostBW: v
                                      };
                                      return next;
                                    });
                                  }}
                                  className="border p-1 w-20"
                                />
                              </td>
                              <td className="px-2 py-1">
                                <input
                                  type="number"
                                  value={mk}
                                  onChange={(e) => {
                                    const v = e.target.value;
                                    setSheetMarkupPerPaper(prev => ({
                                      ...prev,
                                      [pt.key]: v
                                    }));
                                  }}
                                  onBlur={() => applySheetMarkupForPaper(pt.key)}
                                  className="border p-1 w-16"
                                />
                              </td>
                              <td className="px-2 py-1">
                                ${(entry.priceColor || 0).toFixed(4)}
                              </td>
                              <td className="px-2 py-1">
                                ${(entry.priceBW || 0).toFixed(4)}
                              </td>
                            </tr>
                          );
                        })
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>

              {/* Sheet quantity discounts */}
              <div className="space-y-2">
                <h3 className="font-semibold">Sheet Quantity Discounts</h3>
                <p className="text-xs text-gray-600">
                  Discounts are applied per total number of sheets. Highest matching minimum
                  wins.
                </p>
                <div className="space-y-1">
                  {sheetQtyDiscounts.map((disc, idx) => (
                    <div key={idx} className="flex items-center gap-2 text-xs">
                      <span>Min sheets:</span>
                      <input
                        type="number"
                        value={disc.minQty}
                        onChange={(e) => {
                          const v = parseInt(e.target.value, 10) || 0;
                          setSheetQtyDiscounts(prev => {
                            const next = [...prev];
                            next[idx] = { ...next[idx], minQty: v };
                            return next;
                          });
                        }}
                        className="border p-1 w-16"
                      />
                      <span>Discount %:</span>
                      <input
                        type="number"
                        value={disc.discountPercent}
                        onChange={(e) => {
                          const v = parseFloat(e.target.value) || 0;
                          setSheetQtyDiscounts(prev => {
                            const next = [...prev];
                            next[idx] = { ...next[idx], discountPercent: v };
                            return next;
                          });
                        }}
                        className="border p-1 w-16"
                      />
                      <button
                        type="button"
                        onClick={() =>
                          setSheetQtyDiscounts(prev => prev.filter((_, i) => i !== idx))
                        }
                        className="text-red-500 text-xs"
                      >
                        Remove
                      </button>
                    </div>
                  ))}
                </div>
                <button
                  type="button"
                  onClick={() =>
                    setSheetQtyDiscounts(prev => [
                      ...prev,
                      { minQty: 0, discountPercent: 0 }
                    ])
                  }
                  className="px-3 py-1 border rounded bg-gray-100 text-xs"
                >
                  Add Discount Tier
                </button>
              </div>

              {/* Large format pricing */}
              <div className="space-y-3">
                <h3 className="font-semibold">Large Format Pricing</h3>
                <p className="text-xs text-gray-600">
                  Pricing here is per square foot.
                </p>
                <div className="overflow-auto max-h-96 border rounded">
                  <table className="min-w-full text-xs">
                    <thead className="bg-gray-100">
                      <tr>
                        <th className="px-2 py-1 text-left">Paper Type</th>
                        <th className="px-2 py-1 text-left">Base cost / sq ft</th>
                        <th className="px-2 py-1 text-left">Markup %</th>
                        <th className="px-2 py-1 text-left">Price / sq ft</th>
                      </tr>
                    </thead>
                    <tbody>
                      {LARGE_FORMAT_PAPERS.map(pt => {
                        const entry = lfPricing[pt.key] || {
                          baseCostPerSqFt: 0,
                          pricePerSqFt: 0
                        };
                        const mk = lfMarkupPerPaper[pt.key] || 0;
                        return (
                          <tr key={pt.key} className="border-t">
                            <td className="px-2 py-1">{pt.label}</td>
                            <td className="px-2 py-1">
                              <input
                                type="number"
                                step="0.0001"
                                value={entry.baseCostPerSqFt}
                                onChange={(e) => {
                                  const v = parseFloat(e.target.value) || 0;
                                  setLfPricing(prev => {
                                    const next = { ...prev };
                                    const old = prev[pt.key] || {
                                      baseCostPerSqFt: 0,
                                      pricePerSqFt: 0
                                    };
                                    next[pt.key] = {
                                      ...old,
                                      baseCostPerSqFt: v
                                    };
                                    return next;
                                  });
                                }}
                                className="border p-1 w-24"
                              />
                            </td>
                            <td className="px-2 py-1">
                              <input
                                type="number"
                                value={mk}
                                onChange={(e) => {
                                  const v = e.target.value;
                                  setLfMarkupPerPaper(prev => ({
                                    ...prev,
                                    [pt.key]: v
                                  }));
                                }}
                                onBlur={() => applyLfMarkupForPaper(pt.key)}
                                className="border p-1 w-16"
                              />
                            </td>
                            <td className="px-2 py-1">
                              ${(entry.pricePerSqFt || 0).toFixed(4)}
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              </div>

              {/* Large format quantity discounts */}
              <div className="space-y-2">
                <h3 className="font-semibold">Large Format Quantity Discounts</h3>
                <p className="text-xs text-gray-600">
                  Discounts are applied per total square footage. Highest matching minimum wins.
                </p>
                <div className="space-y-1">
                  {lfQtyDiscounts.map((disc, idx) => (
                    <div key={idx} className="flex items-center gap-2 text-xs">
                      <span>Min sq ft:</span>
                      <input
                        type="number"
                        value={disc.minQty}
                        onChange={(e) => {
                          const v = parseFloat(e.target.value) || 0;
                          setLfQtyDiscounts(prev => {
                            const next = [...prev];
                            next[idx] = { ...next[idx], minQty: v };
                            return next;
                          });
                        }}
                        className="border p-1 w-16"
                      />
                      <span>Discount %:</span>
                      <input
                        type="number"
                        value={disc.discountPercent}
                        onChange={(e) => {
                          const v = parseFloat(e.target.value) || 0;
                          setLfQtyDiscounts(prev => {
                            const next = [...prev];
                            next[idx] = { ...next[idx], discountPercent: v };
                            return next;
                          });
                        }}
                        className="border p-1 w-16"
                      />
                      <button
                        type="button"
                        onClick={() =>
                          setLfQtyDiscounts(prev => prev.filter((_, i) => i !== idx))
                        }
                        className="text-red-500 text-xs"
                      >
                        Remove
                      </button>
                    </div>
                  ))}
                </div>
                <button
                  type="button"
                  onClick={() =>
                    setLfQtyDiscounts(prev => [
                      ...prev,
                      { minQty: 0, discountPercent: 0 }
                    ])
                  }
                  className="px-3 py-1 border rounded bg-gray-100 text-xs"
                >
                  Add Discount Tier
                </button>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<PriceCalculatorApp />);
  </script>
</body>
</html>
